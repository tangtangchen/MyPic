[TOC]



# Java基础

## Java中int跟Integer的区别

int是基本数据类型，Integer则是包装类型；后者可以用于泛型；

前者有默认值且不是null，后者不赋值就是null；

比较方式不同，对于基本数据类型来说，“==”比较的是值，而对于包装数据类型 “ ==”比较的是对象的内存地址。

| 基本类型 | 位数 | 字节 | 默认值  |
| :------: | :--: | :--: | :-----: |
|   int    |  32  |  4   |    0    |
|  short   |  16  |  2   |    0    |
|   long   |  64  |  8   |   0L    |
|   byte   |  8   |  1   |    0    |
|   char   |  16  |  2   | 'u0000' |
|  float   |  32  |  4   |   0f    |
|  double  |  64  |  8   |   0d    |
| boolean  |  1   |      |  false  |



## 包装类型的常量池技术

字符串的创建耗费大量的时间和空间，频繁创建字符串影响程序性能。创建字符串时，首先会判断字符串常量池是否有该字符串，如果有直接引用，没有才会实例化字符串，并放入常量池。（**包装类默认创建的缓存数据只适用与[-128.127]这个范围，若超出任然会去创建新的对象**）

### 有包装类型的原因：

包装类型可以用于泛型，基本数据类型不行

### 包装类型的缓存机制:

Byte、Integer、Short、Long这四种包装类型默认创建了数值【-128，127】的相应类型的缓存数据，

Character创建了数值在【0，127】范围的缓存数据，

Boolean` 直接返回 `True` or `False，

两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制



## 自动拆装箱

基本类型与包装类型的互换；

装箱就是用了包装类的`valueOf（）`方法；拆箱就是调用了`xxxValue（）`方法；

```java
Integer i = 10 等价于 Integer i = Integer.valueOf(10)
int n = i 等价于 int n = i.intValue();
```



## 自动拆箱引发的 NPE（空指针异常） 问题

数据库查询为null，自动拆箱，用基本数据类型接受有NPE风险；

使用三目运算符不当会导致NPE异常；



## ==跟equals的区别

对于基本数据类型，==比较的是值，对于引用数据类型， ==比较的是对象的内存地址，eqials比较的是内容；



equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象：

- 情况1，类没有重写equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。（如Object类没有重写，String类重写了）
- 情况2，类重写了equals()方法。一般，我们都重写equals()方法来比较两个对象的内容是否相等；



## String、StringBuffer、StringBuilder 的区别

线程安全：String、StringBuffer     线程不安全：StringBuilder

可变性：StringBuffer、StringBuilder   不可变： String

（String类中使用final关键字修饰字符数组来保存字符串，所以String对象不可变）

性能：StringBuilder>StringBuffer>String

(String类改变都会生成一个新的对象，而StringBuffer每次都对 对象 本身进行操作)

`String` 真正不可变有下面几点原因：

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

（直接修改，其实它们已经是指向了一个新的对象）

![image-20230531145433052](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230531145433052.png)

###  String类为什么设置成不可变的

设置成不可变的总共有四个好处：

1.字符串常量池的实现

通过字符串常量池，我们就可以节约大量的内存空间。如果不设置为不可变，字符串不可复用。

2.用作HashMap的key

String是不可变的可以很方便的用作HashMap的key；

对于HashMap的工作原理是哈希函数，会通过哈希函数计算的值去找到对于的value，如果String为可变的，改变其值之后，哈希值就变化了，会找不到对应的value。

3.用于缓存HashCode

4.线程安全

不可变的对象一定是线程安全的，可以安全的被多个线程共享。

### 字符串拼接用“+” 还是 StringBuilder

在JDK9之前，每次使用“+”号相当于自动创建了 `StringBuilder`进行拼接，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。。但是这种使用在循环中不合适，每次循环都会创建一个 `StringBuilder`对象，影响性能。

在JDK9之后，“+”改用动态方法`makeConcatWithConstants（）`实现，而不是大量的 `StringBuilder`。



## 重载和重写

重载：

发生在同一个类中（或者父类和子类之间），方法名相同，参数类型不同、个数不同、顺序不同、方法返回值和访问修饰符可以不同。

（**重载就是同一个类多个同名方法根据不同的传参来执行不同的逻辑处理**）

重写：

重写发生在运行期间，是子类对父类的允许访问的方法的实现过程进行重新编写。（**外部样子不能改变，内部逻辑可以改变**）

![image-20230531150025204](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230531150025204.png)



## 构造器（constructor）是否可被重写（override）

构造器不能被继承，所以不能被重写，但是可以被重载；

每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。



## 接口和抽象类有什么不同

接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。



## 浅拷贝和深拷贝（对象拷贝）

![image-20230802103247804](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802103247804.png)

上图为引用拷贝，不属于浅拷贝和深拷贝，两个变量此时指向同一个对象，任意一个变量操作了对象的属性，都会发生改变。

浅拷贝：

![image-20230802103620999](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802103620999.png)

![image-20230802103641085](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802103641085.png)

![image-20230802104106289](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802104106289.png)



两个变量指向不同的对象，各自改变自己的属性，不影响另一个对象。但如果拷贝的对象中有属性属于引用数据类型，浅拷贝则仅负责引用数据类型的引用地址。

深拷贝：

![image-20230802104217596](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802104217596.png)



## Object 类的常见方法

clone（）：拷贝一份对象；

wait（）：等待一份线程；

hashCode（）：返回对象的哈希值；

getclass（）：获得当前对象的class对象；

equals（）：object类没有重写，与==相同；String类重写，比较引用对象的值；

notify（）：唤醒一份线程；

finalize（）：实例被垃圾回收的时候触发；



## Java 异常类层次结构图

![image-20230802115715450](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802115715450.png)

**Checked Exception** 即 **受检查异常** ，Java 代码在编译过程中，如果受检查异常没有被 `catch`或者`throws` 关键字处理的话，就没办法通过编译。

**Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。



## Java 反射

### 反射有什么优点/缺点

通过反射可以获取任意一个类的所有属性和方法，还可以调用这些属性和方法。

优点：可以让代码变得更加灵活，为各种框架提供开箱即用的功能提供了便利

缺点：让我们在运行时有了分析操作类的能力，同时也增加了安全问题，例如可以无视泛型参数的安全检查。

框架中大量使用了动态代理，而动态代理的实现也依赖反射。

### 获得class对象的方式

- 通过 `Class.forName()`传入类的全路径获取
- 通过对象实例`instance.getClass()`获取
- 通过类加载器`xxxClassLoader.loadClass()`传入类路径获取



## Java 泛型

### 泛型的作用

泛型是JDK5引入的新特性。

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。

泛型使用方式：泛型类、泛型接口、泛型方法。

### 泛型类型擦除

类型擦除：**Java的泛型是伪泛型，因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说的类型擦除**。

泛型本质上其实还是编译器的行为，为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销，编译器通过擦除将泛型类转化为一般类。

**既然编译器要把泛型擦除，那为什么还要用泛型呢？用 Object 代替不行吗？**

● 使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。 

● 泛型可以使用自限定类型如 T extends Comparable 。 

### 泛型有哪些限制

**无边界的通配符**：**<?>**       **固定上边界的通配符**：**<? extends E>**       **固定下边界的通配符**： **<? super E>** 

![image-20230531152433617](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230531152433617.png)

### 通配符

#### 通配符 ？和泛型 T 区别

- **T** 可以用于声明变量或常量而 **?** 不行。
- **T** 一般用于声明泛型类或方法，通配符 **?** 一般用于泛型方法的调用代码和形参。
- **T** 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。

#### ? extends xxx 和 ? super xxx 有什么区别?

两者接收参数的范围不同。并且，使用 ? extends xxx 声明的泛型参数只能调用 get() 方法返回 xxx 类型，调用 set() 报

错。使用 ? super xxx 声明的泛型参数只能调用 set() 方法接收 xxx 类型，调用 get() 报错。



## 序列化/反序列化

序列化：将数据结构或对象转换成二进制字节流的过程。

反序列化：将序列化过程中产生的二进制字节流转化为数据结构或对象的过程。

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**

序列化和反序列化应用场景：

- 对象进行网络传输之前进行序列化，接受到序列化对象之后进行反序列化；
- 对象存储到文件之前需要进行序列化，将对象从文件中取出需要进行反序列化；
- 对象存储到数据库（Redis）之前需要进行序列化，从数据库中取出对象现需要进行反序列化；
- 将对象存储到内存中之前需要进行序列化，从内存中取出对象需要进行反序列化。

**不想进行序列化的变量，使用 `transient` 关键字修饰。**



## Java常见语法糖

Java 中最常用的语法糖主要有**泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式**等。

Java 中的 `for-each` 就是一个常用的语法糖。



## BigDecimal

大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

​		**浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。**`BigDecimal`**的等值比较应使用`compareTo（）`方法。**



## 内部类/匿名内部类

![image-20230531160945240](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230531160945240.png)

内部类就是类种类，依附于普通类中，可以间接实现Java类的多继承。

![image-20230531162537638](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230531162537638.png)



## Java常见运行时异常

ArrayStoreException：由于数组存储空间不够引起的异常；

NullPointerException：空指针异常，程序试图访问一个空的数组中的元素或访问空的对象中的方法或变量时产生异常；

IndexOutOfBoundsException：索引越界异常，由于数组下标越界或字符串访问越界引起异常；

ClassCastException：类型转换异常，当把一个对象归为某个类，但实际上此对象并不是由这个类创建的，也不是其子类创建的，则会引起异常；

NoSuchElementException：找不到元素异常；

ArithmeticException：算数运算异常，由于除数为0引起的异常；





---

# Java集合

![Java 集合框架概览](https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png)

![img](https://img-blog.csdn.net/2018091021263378?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlZmVuZ2xpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



## List，Set ，Queue；Map

**List**（对付顺序）：存储元素是有序的、可重复的；

​		底层数据结构

​				`ArrayList：Object【】`数组  			 （线程不安全）

​				`Vector：Object【】`数组					（线程安全，使用`synchronized` 关键字；`Vector`和`Stack`已经被淘汰，推荐使用并发集合类（例如`ConcurrentHashMap、CopyOnWriteArrayList`）

​				`LinkedList`：双向链表		（线程不安全）

**Set**（注重独一无二的性质）：存储元素是无序的、不可重复的；

​		底层数据结构

​				HashSet（无序、唯一）：基于`HashMap`实现，哈希表			（线程不安全）

​				LinkedHashSet：是`HashSet`的子类，内部通过`LinkHashMap`实现，链表+哈希表 		（线程不安全）

​				TreeSet（有序、唯一）：红黑树		（线程不安全）

**Queue**（实现排队功能的叫号机）：先确定前后顺序，存储的元素有序、不可替代；

​		底层数据结构

​				`PriorityQueue：Obeject【】`数组实现二叉堆

​				`ArrayQueue：Object【】` 数组 +  双指针

**Map**（用`key`来搜索）：使用键值对存储，`key`是无序的、不可重复的，`value`是无序的、可重复的；

​		底层数据结构

​				`HashMap`：数据+链表------（解决哈希冲突方法变化）-----》数组+链表/红黑树			（线程不安全）

​				`LinkedHashMap`：继承`HashMap`, 数组+链表/红黑树  		（线程不安全）

​				`TreeMap`：红黑树  		(线程不安全)

​				`Hashtable`：数组+链表组成的，数组是 `Hashtable` 的主体，链表则是主要为了解决哈希冲突而存在的，经过了synchronized的修饰 	（线程安全）



## HashMap扩容原理

HashMap默认的初始化大小为16，之后每次扩容，容量会变为原来的2倍。创建时如果给定了容量初始值，hashmap会将其扩容到2的幂次方大小；

### 必须为2的幂次方原因

因为在hashMap的length等于2的n次方的时候，才会有(取模运算优化)hash%length==hash&(length-1)，哈希算法的目的是为了加快哈希计算以及减少哈希冲突，所以此时&操作更合适，所以在length等于2的幂次方的时候，可以使用&操作加快操作且减少冲突，所以hashMap长度是2的幂次方



## HashMap的负载因子为何默认是0.75

负载因子是0.75的时，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率；



## HashMap/Hashtable的键值是否能为null

HashMap可以，但Hashtable不行。会报NPE（空指针异常）。

所以集合转Map时，一定要注意value值为null时会报NPE异常。



## 链表超过8变成红黑树

【链表超过8变成红黑树，那红黑树转化为链表的话阈值还是8吗？】

当链表长度大于8的时候，如果当前数组的长度小于64，那么先进行数组扩容；大于64时，转换为红黑树；



## 数组、链表、红黑树

【数组、链表、红黑树什么情况下会有共存的状态？共存在的话是几种？三种可以同时存在一个hashmap里是吧？】

ConcurrentHashMap采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap` 1.8 的结构类似，数组+链表/红黑二叉树，Node 只能用于链表的情况，红黑树的情况需要使用 **`TreeNode`**。当冲突链表达到一定长度时，链表会转换成红黑树。



## 集合转换

### 集合转Map

使用`Collectors`类的`toMap（）`方法



---------------------

# Java并发



## 并发编程的三个基本概念

原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行；

可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值；

有序性：即程序执行的顺序按照代码的先后顺序执行。



## 线程



### 线程跟进程

线程是进程划分成的更小的运行单位；

进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位；

一个进程中可以有多个线程，多个线程共享进程中的堆和方法区；线程私有自己的程序计数器、虚拟机栈和本地方法栈；

线程执行开销小，但不利于资源的管理和保护；而进程正相反。



### 线程私有

#### 程序计数器为什么是私有的

线程切换后能恢复到正确的执行位置

#### 虚拟机栈和本地方法栈为什么是私有的

为了保证线程的局部变量不被其他线程访问到



### 使用多线程

充分利用多核CPU的性能，提升系统的性能



### 线程的生命周期和六种状态

线程的生命周期中并不是固定处于某个状态，而是随着代码的执行在不同状态之间切换。

new：初始状态，线程被创建出来但是没有被调用start（）；

runnable：运行状态，线程被调用start（）等待被运行；

blocked：阻塞状态，等待锁释放；

waiting：等待状态，线程需要其他线程做出一些特定动作（通知或中断）

time_waiting：超时等待状态，可以在指定时间后自行返回，而非waiting那样一直等待；

terminated：终止状态，表示该线程已经运行完毕；

![image-20230821214408533](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230821214408533.png)



新建状态（NEW）：

当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值

就绪状态（RUNNABLE）：

当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

运行状态（RUNNING）：

如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。

阻塞状态（BLOCKED）：

阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。 直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状 态。阻塞的情况分三种：

等待阻塞（o.wait->等待对列）：

运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue) 中。 

同步阻塞（lock->锁池）：

运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线 程放入锁池(lock pool)中。

其他阻塞(sleep/join）：

运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。

线程死亡（DEAD）：

线程会以下面三种方式结束，结束后就是死亡状态。 

正常结束 

run()或 call()方法执行完成，线程正常结束。 

异常结束 

线程抛出一个未捕获的 Exception 或 Error。 

调用 stop 3. 

直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用



### 终止线程4种方式

- 正常运行结束

程序运行结束，线程自动结束。

- 使用退出标志退出线程

一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的 运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环

- Interrupt 方法结束线程

使用 interrupt()方法来中断线程有两种情况：

1、线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时， 会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的，一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。 

2、线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。

- stop 方法终止线程（线程不安全）

程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关 闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是： thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子 线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用 thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈 现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因 此，并不推荐使用 stop 方法来终止线程。



### sleep 与 wait 区别

1. 对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于 Object 类中的。 
2.   sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 
3. 在调用 sleep()方法的过程中，线程不会释放对象锁。
4. 而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。



### 线程基本方法

wait、sleep、notify、notifyAll、join、yield等

**wait**：线程等待

调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait（）方法后，会释放对象的锁。因此，wait方法一般用在同步方法或同步代码块中。

**sleep**：线程睡眠

sleep导致当前线程休眠，与wait方法不同的是sleep不会释放当前占有的锁，sleep（long）会导致线程进入TIMEED-WAITING状态

**yield**：线程让步

yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片。

**interrupt**：线程中断

中断一个线程，本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态（如阻塞，终止等）

1. 调用interrupt（）方法并不会中断一个正在运行的线程。也就是说处于Running状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标记位而已。
2. 若调用sleep（）而使线程处于TIMED-WAITING状态，这是调用interrupt（）方法，会抛出InterruptedException，从而使线程提前结束TIMED-WAITING状态。
3. 许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。
4. 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以 根据 thread.isInterrupted()的值来优雅的终止线程。

**Join** ：等待其他线程终止

join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，直到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。

**notify**：线程唤醒

Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象 上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调 用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继 续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞 争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。

其他方法： 

1. sleep()：强迫一个线程睡眠Ｎ毫秒。
2. isAlive()： 判断一个线程是否存活。
3. join()： 等待线程终止。 
4. activeCount()： 程序中活跃的线程数。
5. enumerate()： 枚举程序中的线程。 
6. currentThread()： 得到当前线程。 
7. isDaemon()： 一个线程是否为守护线程。
8. setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线 程依赖于主线程结束而结束) 
9. setName()： 为线程设置一个名称。
10. wait()： 强迫一个线程等待。
11. notify()： 通知一个线程继续运行。 
12. setPriority()： 设置一个线程的优先级。 
13. getPriority():：获得一个线程的优先级。



### 线程上下文切换

假如发生某些情况时（让出CPU、时间片用完、中断），线程切换（保存当前线程上下文，留待下次占用CPU时恢复现场，加载下个占用CPU的线程上下文）。

巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存 下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做 上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。

上下文 是指某一时间点 CPU 寄存器和程序计数器的内容

## Java锁

### 乐观锁（多读场景，竞争较少）：

每次假设最好的情况，认为共享资源每次访问不会出问题，每次去拿数据的时候都认为别人不会修改，所以不会上锁，仅在修改更新的时候去会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。

不存在锁竞争，不会有死锁发生，但如果冲突频繁发生，会频繁的失败与重试，导致CPU飙升。

乐观锁一般会使用版本号机制或 CAS 算法实现（CAS 的全称是 **Compare And Swap（比较与交换）**）。

乐观锁存在的问题：

ABA问题、循环时间长开销大、只能保证一个共享变量的循环操作

#### ABA解决方法

ABA问题就是变量V在初次读取时值为A，准备赋值时读取仍然为A，但是这并不代表中间并没有被改变过。

在变量前面加上**时间戳**或**版本号**



### 悲观锁（多写场景，竞争激烈）：

每次假设最坏的情况，每次去拿数据的时候都认为别人 会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）

**Java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。**

激烈的锁竞争会导致频繁的系统上下文切换，造成系统的性能开销，悲观锁可能会存在死锁问题；



### 自旋锁

如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁 的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋）， 等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程 也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。

在 1.6 引入了适应性自旋锁，适应 性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥 有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间



### Synchronized 同步锁

synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。



#### Synchronized 核心组件

1. Wait Set:那些调用wait方法的线程被放置在这里
2. Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中
3. Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；
4. OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck
5. Owner：当前已经获取所有资源的线程被称为Owner
6. ！Onwer：当前释放锁的线程



### ReentrantLock

ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。

1、ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。 

2. ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock



### Semaphore 信号量

Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池

实现互斥锁（计数器为 1） 我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量， 表示两种互斥状态。

#### Semaphore 与 ReentrantLock 

Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与 release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被 Thread.interrupt()方法中断。 此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。 Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而 无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成



### AtomicInteger

首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有 AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同， 区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference将一个对象的所 有操作转化成原子操作。 我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。 通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些 同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger 的性能是 ReentantLock 的好几倍。



### ReadWriteLock 读写锁

为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 

读锁 

如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 

写锁 

如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上 读锁，写的时候上写锁！ 

ava 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现 ReentrantReadWriteLock。



### 共享锁和独占锁

java 并发包提供的加锁模式分为独占锁和共享锁。

独占锁 

独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。

共享锁

共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。



### 分段锁

分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践

## 预防和避免死锁

预防死锁：

​	破环请求与保持条件；

​	破环不剥夺条件；

​	破环循环等待条件；

避免死锁：

​	资源分配是使用-银行家算法；



## synchronized 关键字

https://zhuanlan.zhihu.com/p/377423211

### synchronized 工作原理

synchronized是一个同步关键字，在多线程场景下，作用于代码同步保护数据共享安全。

`synchronized` 关键字的使用方式主要有下面 3 种：

1. 修饰普通同步方法：锁对象就是当前实例
2. 修饰静态同步方法：锁对象是当前类的Class字节码对象
3. 修饰同步代码块：锁对象是synchronized后面括号里配置的对象，可以是某个对象，也可以是某个类的.class对象。



JVM对于同步方法和同步代码块的处理方式不同，对于同步方法，JVM采用`ACC_SYNCHRONIZED`标记符来实现同步，而对于同步代码块，JVM则采用 `monitorenter`（加锁）和`monitorexit` （释放锁）这两个指令实现同步。

Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是`monitorenter`和 `monitorexit` 指令实现的，而方法同步是通过`Access flags`后面的标识来确定该方法是否为同步方法。



反汇编语言中有两个`monitorexit` 是为了执行异常的`monitorenter`指令。而字节码中多出的`monitorexit`指令，就是**异常结束时**，**被执行用来释放**`monitor`的。



### synchronized特性

**原子性**

原子性指的是在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。

如何保证：

Java内存模型中提供了字节码指令`monitorenter`和`monitorexit` 来隐式的使用这两个操作，在`synchronized`块之间的操作都是具备原子性的。

**可见性**

 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

如何保证：

通过内存屏障。内存屏障按照可见性分为：`load屏障`和`Store屏障`

`load屏障`：执行refresh，从其他处理器的高速缓存、主内存，加载数据到自己的高速缓存，保证数据的最新。

`Store屏障`：执行flush操作，自己处理器更新的变量值，刷新到高速缓存、主内存中。

被`synchronized`修饰的代码，在开始执行时被加锁，执行完毕后解锁，在解锁一个变量之前，必须先把**此变量同步回主存**，这样解锁以后，其他线程就可以访问到被修改后的值，从而保证可见性。

**有序性**

程序执行的顺序按照代码的先后顺序执行。

通过内存屏障。内存屏障按照有序性分为：`Acquire屏障`和`Release屏障`

`Acquire屏障`：load屏障之后，加Acquire屏障。它会禁止同步代码块内的读操作，和外面的读写操作发生指令重排；

`Release屏障`：禁止写操作，和外面的读写操作发生指令重排；

在 monitorenter 指令和 Load 屏障之后，会加一个 Acquire屏障，这个屏障的作用是禁止同步代码块里面的读操作和外面的读写操作之间发生指令重排，在 monitorexit 指令前加一个Release屏障，也是禁止同步代码块里面的写操作和外面的读写操作之间发生重排序。

```java
int a = 0;
synchronize (this){  //monitorenter
    // Load内存屏障
    // Acquire屏障，禁止代码块内部的读，和外面的读写发生指令重排
    int b = a;
    a = 10;    //注意：内部还是会发生指令重排
    // Release屏障，禁止写，和外面的读写发生指令重排
} //monitorexit
//Store内存屏障
```

as-if-serial，synchronized 的有序性，不是 volatile 的防止指令重排序。

**可重入性**

可重入指的就是一个线程可以多次执行synchronized，重复获取同一把锁。

### synchronized关键字可以实现什么类型的锁？

- 悲观锁：`synchronized`关键字实现的是悲观锁，每次访问共享资源时都会上锁。
- 非公平锁：`synchronized`关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。
- 可重入锁：`synchronized`关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。
- 独占锁或者排他锁：`synchronized`关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。



### Synchronzied锁升级

在jdk1.6之前，`synchronized`被称为重量级锁，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁。

无锁->偏向锁（单线程）->轻量级锁（CAS自旋）->重量级锁（阻塞）



**为什么要进行锁优化呢**

JDK1.6之前是通过重量级锁方式去实现线程之间锁竞争的，重量级锁底层依赖操作系统的Mutex Lock来去实现互斥锁的一个功能 。Mutex是系统方法，由于权限隔离的关系，应用程序调用系统方法需要用户态切换到内核状态执行，带来性能上的损耗。

因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的`Mutex Lock`来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大



**引入偏向锁的目的**

减少只有一个线程执行同步代码块时的性能消耗，即在没有其他线程竞争的情况下，一个线程获得了锁。

偏向锁的获取流程：

1. 检查对象头中Mark Word是否为可偏向状态，如果不是则直接升级为轻量级锁。
2. 如果是，判断Mark Work中的线程ID是否指向当前线程，如果是，则执行同步代码块。
3. 如果不是，则进行CAS操作竞争锁，如果竞争到锁，则将Mark Work中的线程ID设为当前线程ID，执行同步代码块。
4. 如果竞争失败，升级为轻量级锁。

偏向锁原理：使用CAS操作将当前线程的ID记录到对象的Mark Word中。



引入轻量级锁的目的：在多线程交替执行同步代码块时（未发生竞争），避免使用互斥量（重量锁）带来的性能消耗。但多个线程同时进入临界区（发生竞争）则会使得轻量级锁膨胀为重量级锁。



**重量级锁的底部实现原理：Monitor**

在JDK1.6版本之后Synchronized增加锁升级的机制，来平衡数据安全性和性能的关系。简单来说，线程去访问Synchronized同步代码块的时候，Synchronized先去尝试在不加重量级锁的情况去保证线程安全性，引入了偏向锁和轻量级锁，偏向锁就是直接把当前锁偏向于某个线程，通过CAS机制来修改偏向锁的一个标记（Mark word中的线程ID改为当场线程ID），该锁适合同一线程多次去访问同一个锁资源的情况，并且没有其他线程竞争的一个场景中。轻量级锁又可以称为自旋锁，基于自适应自旋的机制，通过多次自旋去重试竞争锁（自旋次数过多就会升级到重量级锁），自旋锁的优点在于，避免了用户态到内核态切换带来的性能损耗。



![img](https://pic4.zhimg.com/v2-395840866ccb36a0f139903a7d5ada07_r.jpg)



### 锁消除

锁消除是指Java虚拟机在即时编译时，通过对运行上下的扫描，消除那些不可能存在共享资源竞争的锁。锁消除可以节约无意义的请求锁时间。



### 锁粗化

如果虚拟机检测到有一系列操作都是对某个对象反复加锁和解锁，会将加锁同步的范围粗化到整个操作序列的外部。

经典案例。

```java
for(int i=0;i<n;i++){
    synchronized(lock){
    }
}
```

这段代码会导致频繁地加锁和解锁，锁粗化后

```java
synchronized(lock){
    for(int i=0;i<n;i++){
    }
}
```



### synchronized和volatile的区别

- `volatile`主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。`synchronized`主要是解决多个线程访问资源的同步性。
- `volatile`作用于变量，`synchronized`作用于代码块或者方法。
- `volatile`仅可以保证数据的可见性，不能保证数据的原子性。`synchronized`可以保证数据的可见性和原子性。
- `volatile`不会造成线程的阻塞，`synchronized`会造成线程的阻塞。



## volatile关键字

### volatile关键字是否保证可见性和原子性的原理

**volatile**关键字保证数据的可见性，无法保证数据的原子性；

将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取；

**volatile**是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized，volatile更轻量级；

`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序



## ReentrantLock

`ReentrantLock`实现了Lock接口，是一个可重入且独占式锁（**可重入锁** 也叫递归锁，指的是线程可以再次获取自己的内部锁）。和`synchronized`关键字类似，而且更强大、更灵活，增加了轮询、超时、中断、公平锁、非公平锁等功能。

![image-20230803150547162](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230803150547162.png)

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 AQS（`AbstractQueuedSynchronizer`），添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。

`ReentrantLock` 的底层就是由 AQS 来实现的。

### 公平锁和非公平锁

**公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。

**非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

### ReentrantLock和synchronized区别

- 二者都是可重入锁
- `ReentrantLock`依赖JDK（API）实现，`synchronized`依赖JVM实现
- 前者功能更加强大
- 前者实现了公平锁，后者只有非公平锁
- 前者实现了可中断锁，后者无

**可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。`ReentrantLock` 就属于是可中断锁。



## AQS

AQS就是一个抽象类，主要用来构建锁和同步器，为锁和同步器提供一些实现。

### AQS原理

如果被请求的共享资源空闲，那么将这个请求线程作为工作线程，将共享资源设为独占资源。**如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制就是AQS基于CLH锁实现的。**

CLH锁：是对自旋锁的一种改进，是一个虚拟的双向队列，暂时获得不到锁的线程会加入到该队列中。

#### AQS两种资源共享方式

1. `Exclusive`。（独占，只有一个线程能执行，如`ReentrantLock`）
2. `Share`。（共享，多个线程同时执行，如`Semaphore/CountDownLatch`）

同时实现两种资源共享方式的，如`ReentrantReadWriteLock`。

#### 基于AQS的常见同步类

**Semaphore（信号量）**

`Semaphore`(信号量)可以用来控制同时访问特定资源的线程数量。

**CountDownLatch （倒计时器）**

`CountDownLatch` 允许 `count` 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。

**CyclicBarrier(循环栅栏)**

让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。











## ThreadLocal

`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。

![img](https://javaguide.cn/assets/1-af0577dc.png)



## 创建线程

1. 继承Thread类：自己的类没有继承类就可以通过继承Thread类创建线程，Thread类本质上是实现了Runnable接口的一个实例。启动线程的唯一方法是通过Thread类的start（）方法，start（）方法是一个native方法，它启动线程并执行run（）方法。
2. 实现Runnable接口：当自己的类已经继承了另一个类，就无法直接继承Thread类，此时可以通过实现Runnable接口方式创建线程。首先先需要实例化Thread，将自己的MyThread实例传入
3. 实现Callable接口：**有返回值的任务必须实现Callable接口，并可以抛出异常，无返回值的任务必须实现Runnable接口**。执行Callable任务后可以获得一个Future对象，该对象上调用get就可以得到Callable任务返回的Object，再结合线程池接口ExecutorService就可以实现有返回结果的多线程。
4. 线程池方式创建：为了避免重复创建销毁，采用此方式。Java提供了构建线程池的方式（Executors类）

注：继承Thread实际上就是实现Runable，

## 线程池

### 创建线程池

1. **通过`ThreadPoolExecutor`构造函数创建**（推荐手动创建线程池）
2. **通过`Executor`框架的工具类`Executors`来创建**（规范中不推荐这种方式去创建线程池，因为这种方式对线程的控制粒度比较低，导致OOM）

#### JDK基于Executors提供的5种线程池

- `newSingleThreadExecutor`：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。（单例线程池）
- `newFixedThreadPool`：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。（定长线程池） 
- `newCachedThreadPool`：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 （缓存线程池，没有核心线程）
- `newWorkStealingPool`：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。（工作窃取线程池）
- `newScheduleThreadPool`：（定时任务线程池，每个线程都有自己的阻塞队列，当自己的阻塞队列满了时，会去其他线程的阻塞队列窃取）

### 线程池的七个参数

手动创建线程池，要对线程池的七个参数有所了解

`corePoolSize`：核心线程数

`maximumPoolSize`：最大线程数

`keepAliveTime`：最大空闲时间

空闲时间内没有新任务，此 线程资源会释放

`unit`： 时间单位

空闲时间单位，如秒、毫秒等

`workQueue`：阻塞队列

当核心线程都在运行时，来任务就加入到其中

`ThreadFactoty`：线程工厂

给线程指定名称，当线程出现问题时，可以直接锁定发生位置

`handler` ：拒绝策略：

当所有线程都在繁忙，workQueue 也放满时，会触发拒绝 策略



### 核心参数该如何设置





### 线程池的饱和（拒绝）策略

1. AbortPolicy：直接丢弃任务，抛出异常，这是默认策略

2. CallerRunsPolicy：只用调用者所在的线程来处理任务 
3. DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务 
4. DiscardPolicy：直接丢弃任务，也不抛出异常



### 线程池状态

线程池的核心属性就是ctl，基于ctl拿到**线程池的状态**以及**工作线程的个数**

ctl实际上是一个32位的int类型，高三位为线程池状态，低29位是工作线程个数

五个状态：

111：RUNNING状态，RUNNING 可以处理任务，并且处理阻塞队列中的任务

000：SHUTDOWN状态，不会接收新任务，正在处理的任务正常进行，阻塞队列的任务也会做完

001：STOP状态，不会接受新任务，正在处理任务的线程会被中断，阻塞队列的任务一个不管

010：TIDYING状态，这个状态是SHUTDOWN或者STOP转换过来的，代表当前线程池马上关闭，就是过渡状态

011：TERMINATED状态，这个状态是TIDYING状态转换过来的，转换过来只需要执行一个terminated方法。

![image-20230821203650414](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230821203650414.png)

其中正在处理任务的线程会被中断，不一定保证中断，看任务逻辑中是否有线程中断标记位的出口，有则中断



### 线程池为何要构建空任务的非核心线程

核心线程为0，阻塞队列有任务，导致任务饥饿

导致这种情况发生有两种：

1. 创建线程池时设置核心线程数量为0
2. 核心线程默认是不可以超时的，但是可以修改属性`allowCoreThreadTimeOut`为true，可以超时



### 线程池处理任务流程

![image-20230803161712295](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230803161712295.png)

1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。
2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。
3. 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。
4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用`RejectedExecutionHandler.rejectedExecution()`方法。

### 线程池核线程数配置

分为**CPU密集型**和**IO密集型**

CPU密集型： N（CPU 核心数）+1

IO密集型：CPU核心数量*2。



### 





## Future类

`Future` 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。

核心思想是**异步调用，主要用在多线程领域**，并非 Java 语言独有。



## Executor框架

Java5引进的，通过`Executor`来启动线程比`Thread`的`start`方法更好。更易管理，效率更好（用线程池实现），关键：有助于避免this逃避问题。

this逃避问题：指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。

Executor框架组成：

1. **任务**：实现Runable和callable接口
2. **任务的执行**：Executor
3. **异步计算的结果**：Future



## Java常见并发容器

`ConcurrentHashMap`：线程安全的 `HashMap`。

**`CopyOnWriteArrayList`** : 线程安全的 `List`，在读多写少的场合性能非常好，远远好于 `Vector`。

**`ConcurrentLinkedQueue`**: 高效的并发队列，使用链表实现。可以看做一个线程安全的 `LinkedList`，这是一个非阻塞队列。

**`BlockingQueue`** : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。

**`ConcurrentSkipListMap`**: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。



-------------

# IO

![image-20230802155634352](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802155634352.png)



## BIO,NIO,AIO 

UNIX系统下I/O模型：同步阻塞I/O、同步非阻塞I/O、I/O多路复用、信号驱动I/O、异步I/O

Java中常见的I/O模型：

​		BIO:同步阻塞IO模型，应用程序调用后，会一直阻塞，直到内核把数据拷贝到用户空间。面对十万甚至百万级连接时，无能为力；

​		NIO：I/O多路复用模型，对于高负载、高并发的应用，使用NIO（**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**）;

​		AIO：也是NIO2，异步IO模型；

【传统的BIO模型处理连接少，而同步非阻塞IO模型会不停进行I/O系统的调用，消耗CPU资源。此时NIO的引入，线程通过select调用，询问内核是否准备好，再发起read调用，调用过程依然是阻塞的，减少无效的系统调用，减少CPU的消耗。改进版的NIO也就是AIO的出现，异步IO基于事件和回调机制实现的，性能没有多大改变】

IO是面向流的，NIO是面向缓冲区的

![image-20230707142749768](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707142749768.png)

![image-20230707142844624](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707142844624.png)

![image-20230707143038230](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707143038230.png)

### NIO核心组件

**Buffer（缓冲区）**：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer中，而写操作时将 Buffer中的数据写入到 Channel 中。

**Channel（通道）**：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过Channel来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。

**Selector（选择器）**：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到Selector上，由Selector来分配线程来处理事件。



## 常见实现I/O多路复用的方式

- select
- poll
- epoll



## IO中的设计模式

### 装饰器模式

字节流中的`FilterInputStream` （对应输入流）和`FilterOutputStream`（对应输出流）是装饰器模式的核心，分别用于增强 `InputStream` 和`OutputStream`子类对象的功能。

### 适配器模式

IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的

### 工厂模式

工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 `Files` 类的 `newInputStream` 方法用于创建 `InputStream` 对象（静态工厂）、 `Paths` 类的 `get` 方法创建 `Path` 对象（静态工厂）、`ZipFileSystem` 类（`sun.nio`包下的类，属于 `java.nio` 相关的一些内部实现）的 `getPath` 的方法创建 `Path` 对象（简单工厂）。

### 观察者模式

NIO 中的文件目录监听服务使用到了观察者模式。



---

# JVM

![img](https://camo.githubusercontent.com/ef5d566ab06b1a3f3f3f260c6634ee02c5f7bca5/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303135373431362e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31342c636f6c6f725f4646464646462c745f3730)



## JVM内存模型

### 线程私有

**程序计数器**：保存着当前线程执行的字节码位置，每个线程都有自己独立的计数器，只为Java程序服务。执行本地native方法时，程序计数器为0。

**虚拟机栈**：线程执行方法是都会创建一个栈阵，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回式执行出栈。

**本地方法栈**：与栈类似，也是保存执行方法的信息，执行Java方法的是使用栈，执行Natice方法使用本地方法栈。

### 线程共享

**堆**：JVM内存管理中最大的一块，被线程共享，所有的对象实例存储在其中。当堆没有可用空间时，会发生OOM泄露。根据对象的存货周期不同，根据将对象分代管理，采用垃圾回收机制进行垃圾的回收管理。

![堆内存结构](https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png)

**方法区**：非堆区，用于存储已经被虚拟机加载的类信息，常量，静态变量。



## 虚拟机在Java中对象创建过程

### 对象的创建

类加载验证-->内存分配-->初始化零值-->设置对象头-->执行init方法

#### Step1：类加载检查

当虚拟机遇见一个new命令时，首先去常量池查找对应的符号引用是否被加载、解析、初始化过，如果没有，必须先执行对应的类加载过程。

#### Step2：分配内存

在类加载过程之后，虚拟机为对象分配内存。对象所需要的空间，类加载检查之后就可以确定。分配方式有两种，**“指针碰撞”**和**“空闲列表”**，选择哪种分配方式，**由Java堆是否规整决定**，Java堆是否规整，**由所采用的垃圾回收器是否有压缩整理功能决定**。

（而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。）

##### 指针碰撞

- 适用场合：堆内存规整（即没有内存碎片）的情况下。
- 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
- 使用该分配方式的 GC 收集器：Serial, ParNew

##### 空闲列表

- 适用场合：堆内存不规整的情况下。
- 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
- 使用该分配方式的 GC 收集器：CMS

##### 内存分配并发问题解决方案

**CAS+失败重试**：虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。

**TLAB**：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。

#### Step3：初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。

#### Step4：设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### Step5：执行init方法

从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**

**对象头**：包括两部分信息，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据**：**对象真正存储的有效信息**。

**对齐填充**：不是必然存在的，也没有什么特别的含义，仅仅起占位作用。

### 对象的访问定位

对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**（主流）、**直接指针**

## 内存分配原则

### 对象优先在Eden区分配

### 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

### 长期存活的对象将进入老年代

关于默认的晋升年龄是 15，CMS 是 6。

## 主要进行GC的区域

 GC 其实准确分类只有两大种：

### 部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

### 整堆收集 (Full GC)：

收集整个 Java 堆和方法区。



## 死亡对象判断方法

- 引用计数法
- 可达性分析算法



## Java的四种引用类型

- **强引用**：常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候。
- **软引用**：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收。
- **弱引用**：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收。
- **虚引用**：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知。



## 垃圾收集算法

### 标记-清除算法

标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

### 复制算法

为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

### 标记-整理算法

标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法(主流)

根据对象存活周期的不同将内存分为几块。



## 垃圾回收器

-  **Serial （串行）收集器**

一个单线程收集器，新生代采用标记-复制算法，老年代采用标记-整理算法。

- **ParNew 收集器**

 Serial 收集器的多线程版本

-  **Parallel Scavenge 收集器**

使用标记-复制算法的多线程收集器。Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。

- **CMS 收集器**

**以获取最短回收停顿时间为目标的收集器**。它非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机**第一款真正意义上的并发收集器**，它第一次实现了让**垃圾收集线程与用户线程（基本上）同时工作**。

 “标记-清除”算法实现的。	

- **G1 收集器**

G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.

- **Serial Old 收集器**

Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案

- **Parallel Old 收集器**

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器



## 类的生命周期

加载、验证、准备、解析、初始化、使用、卸载

![一个类的完整生命周期](https://oss.javaguide.cn/github/javaguide/java/jvm/lifecycle-of-a-class.png)



## 类加载过程

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

![类加载过程](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png)

**加载**：读取.class文件，将其转化为静态数据结构存储在方法区，并在堆中生成便于用户调用的java.lang.Class类型的对象的过程。

 （此处class不仅仅是本地文件，泛指各种来源的二进制流，网络、数据库、即时生成的class文件，像动态代理技术，就是用到即时计算出来的class，然后实例化代理对象）

**验证**：**加载阶段**已经对**文件格式**进行了验证，所以该阶段进行**1、元数据验证 |2、字节码的验证**，简单概括就是对class静态结构进行语法和语义上的分析，保证其不会危害虚拟机。最后进行**符号引用**方面的验证，发生在**解析阶段**。

（验证其实包括很多个步骤，分散在各个阶段内）

**准备**：为该类型中定义的静态变量赋0值。

**解析**：将符号引用替换为直接引用。

当一个Java类编译成class类之后，这个类被称为A， A中引用了B，在编译阶段，A并不知道知道B有没有被编译，不知道B的实际地址，此时在A的class文件中，将使用一个字符串S来代表B的地址，S就被称为符号引用。在运行时，如果A的类加载发现B未加载，触发B的类加载，A中符号引用将会替换为B对象实际地址，这就是直接引用。

​		动态解析（解析阶段有时在初始化阶段之后原因，实现后期绑定）：

如果A调用的B是一个具体的实现类，那么就是静态解析。假若Java使用了多态，B是一个接口或者抽象类，那么可能有两个具体的实现类C和D，所以B的具体实现并不明确，不知道用C、D的哪个具体实现进行替换，进行等待。所以直到运行过程中发生调用，此时虚拟机得到具体类型信息，此时再进行解析，用直接引用替换符号引用。底层对应使用了invokedynamic这条字节码指令。

**初始化**：是否存在主动的资源初始化操作。







---

# MySQL



## MyISAM和InnoDB的对比

前者是5.5.5版本之前的默认存储引擎，后者是当前的默认存储引擎。

- MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
- MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。[MySQL 事务隔离级别详解](https://javaguide.cn/database/mysql/transaction-isolation-level.html)
- MyISAM 不支持外键，而 InnoDB 支持
- 数据库异常崩溃后的安全恢复。MyISAM 不支持，而 InnoDB 支持。（使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log`）
- MyISAM 不支持MVCC，而 InnoDB 支持。
- MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。
- InnoDB 的性能比 MyISAM 更强大。



## 聚簇索引和非聚簇索引

### 介绍

​		聚簇索引就是索引和数据放在一起，找到索引也就找到数据。非聚簇索引将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键。

**聚簇索引又称聚集索引，二级索引又称非聚簇索引**

![image-20230707173643593](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707173643593.png)

（InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录）

![image-20230707155112836](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707155112836.png)

### 聚簇索引优缺点

优点：

1. **查询速度非常快**。（因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。）
2. **对排序查找和范围查找优化**：聚簇索引对于主键的排序查找和范围查找速度非常快。

缺点：

1. **依赖于有序的数据**：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大**：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。

### 回表查询

从二级索引（非聚簇索引）中拿到叶子节点上主键的值，再用该值去聚集索引上查找，由此可以得到该主键值对应的整行数据。

![image-20230707174057622](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707174057622.png)





## 覆盖索引

覆盖索引：查询中使用了索引，并且需要返回的列，在该索引中已经能全部找到。



## InnoDB 实现的 REPEATABLE-READ 解决幻读问题

1. **快照读**：由 MVCC 机制来保证不出现幻读。
2. **当前读**：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。

InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。

![image-20230707171015342](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707171015342.png)



## explain命令

用到 explain 这个命令来查看一个这些 SQL 语句的执行计划，查看该 SQL 语句有没有使用上了索引，有没有做全表扫描。

例如：

```mysql
mysql> explain select * from servers;
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
```

![image-20230707172014677](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707172014677.png)

Using index condition -->索引有优化空间。

![image-20230707172220294](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707172220294.png)



## MySQL中，如何定位慢查询

![image-20230707171428632](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707171428632.png)

![image-20230707171459003](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707171459003.png)

![image-20230707171600872](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707171600872.png)



## SQL语句执行很慢，如何分析

![image-20230707172313276](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707172313276.png)



## MySQL锁类型

![image-20230801115014599](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230801115014599.png)





----

# Redis

![image-20230705153206605](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705153206605.png)



## 缓存击穿/缓存雪崩/缓存穿透

### 缓存击穿

​		是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。

![image-20230705144454081](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705144454081.png)

解决方案：

1. 使用互斥锁，使用Redis的setnx去设置一个互斥锁。
2. 设置当前缓存逻辑过期(永远不过期)。	

**永远不过期"**

这里的“永远不过期”包含两层意思：

(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。

(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期

![image-20230705145027681](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705145027681.png)

### 缓存雪崩

​		缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

​		或着Redis服务宕机。

解决方案：

1. 可以将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重 复率就会降低，就很难引发集体失效的事件。
2. 面对Redis服务宕机，利用Redis集群提高服务的可用性（哨兵模式、集群模式）
3. 给缓存业务添加降级缓存限流策略（ngxin或spring cloud gateway（降级可以作为系统的保底策略，适用于击穿、雪崩和穿透））
4. 给业务添加多级缓存（使用Guava或Caffeine做一级缓存，Redis做二级缓存）

（缓存击穿和缓存雪崩的区别：雪崩是很多key，击穿是某一个key缓存）

### 缓存穿透

​		指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。

解决方案：

1. 缓存无效key，设置null在缓存上
2. 使用布隆过滤器

### 布隆过滤器

依靠位图（bitmap）实现

误判率：数组越大误判率就越小，数组越小误判率越大，但是同时带来了更多的内存消耗。

实现方案：

1. Redisson
2. Guava（谷歌开源）



## 如何保证数据库与缓存一致性

![image-20230705153113230](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705153113230.png)

先观察自己业务是 **一致性要求比较高**还是**允许一定延迟**，不同需求所使用的方案不同。

读操作：缓存命中，直接返回，未命中，查询数据库，写入缓存，设定超时时间。

写操作：延迟双删：

![image-20230705150805646](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705150805646.png)

无论是先删除缓存，再操作数据库；还是先操作数据库，再删除缓存都会出现问题。

删两次缓存是为了减少脏数据的出现。

延迟双删是因为一般情况下，数据库是主从模式，延时一会为了主数据库同步到从数据库。但是延时时间不好控制，仍然有可能有脏数据的出现。

###一致性要求高：

一般情况下，操作数据库读多写少，使用读写锁；

共享锁：读锁readLock，加锁以后，其他线程可以共享读操作；

排他锁：独占锁writeLock，加锁以后，阻塞其他线程读写操作；

![image-20230705152436661](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705152436661.png)

### 允许一定延迟：

异步通知保证数据的最终一致性

![image-20230705152718980](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705152718980.png)

基于Canal的异步通知

![image-20230705152912644](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705152912644.png)



## 持久化RDB和AOF对比

![image-20230705154749662](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705154749662.png)



## Redis的数据过期策略

### 惰性删除：

在设置该key过期时间后，不去管它，当需要该key时，检查其是否过期，如果过期就删掉，反之则返回该key。

优点：对cpu比较友好，不需要浪费时间进行过期检查。

缺点：对内存不友好，一个key过期以后但是一直没有使用，那么该key一直存在内存中，内存永远不会释放。

### 定期删除：

每隔一段时间，就对一些key进行检查，删除里面的过期key。（从一定数量的数据库中取出一定数量的随机key进行检查）

定期删除有两种模式：

1. SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，通过修改配置文件中的redis.conf中的来调节次数。
2. Fast模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms。

（执行时间这么短是为了尽量少的去占用主进程的操作，未删除完可以继续删除）

优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。也能够有效的释放占用的内存。

缺点：难以确定删除操作执行的时长和频率。

Redis的过期删除策略是：惰性删除+定期删除两种策略配合使用



## Redis的数据淘汰策略

【（缓存过多，内存被占满了怎么办）】

数据的淘汰策略：当Redis的内存不够时，此时向Redis中添加新的key，那么Redis会按照某一规则将内存中的数据删掉，这种删除规则被称为内存的淘汰策略。

Redis一共有八种内存淘汰策略，默认是noevction：

![img](https://pic2.zhimg.com/v2-bb57a78a0d780a0301a77e4280c3c67d_r.jpg)

noevction：不淘汰任何key，但是内存满时不允许写入新数据。

volatile-ttl ：（将要过期的数据淘汰）对设置了TTL的key，比较key的剩余ttl值，ttl值越小越先被淘汰。

volatile-lru：（最近最少使用的数据淘汰）对于设置了TTL的key，基于LRU进行淘汰。

volatile-lfu：（最不经常使用的数据淘汰）对于设置了TTL的key，基于LFU进行淘汰。

volatile-random：（任意选择数据淘汰）对于设置了TTL的key，随机淘汰。

allkeys-lru：（最近最少使用的数据淘汰）对于全体key，基于LRU算法进行淘汰。

allkeys-random：（任意选择数据淘汰）对于全体key，随机淘汰。

allketys-lfu：（最不经常使用的数据淘汰）对于全体key，基于LFU进行淘汰。

使用建议：

- 优先使用allkeys-lru策略。充分利用LRU算法的优势，把最近最常访问访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。
- 业务中数据访问频率差别不大，没有明显的冷热数据区分，建议使用allkeys-random，随机淘汰。
- 业务中如果有置顶的需求，可以使用volatile-lru策略，同时置顶数据不设置过期时间，这些数据一直不会被删除，会淘汰其他设置了过期时间的数据。
- 业务中如果有短时高频访问数据，推荐使用allkeys-lfu或volatile-lfu策略。

![image-20230705162557769](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705162557769.png)

![image-20230705164001359](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705164001359.png)



## Redis分布式锁

![image-20230705171306135](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705171306135.png)



分布式锁使用场景：集群情况下的定时任务、抢单抢券秒杀、幂等性场景

Redis实现分布式锁主要利用Redis的setnx命令

![image-20230705165313990](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705165313990.png)

设置过期时间是为了防止死锁产生

### redisson实现分布式锁

给锁续期----》redisson实现的分布式锁-执行流程（redisson实现分布式锁也是基于redis的setnx命令实现的）

![image-20230705165845647](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705165845647.png)

（其中加锁、设置过期时间等操作都是基于lua脚本完成的）

### redisson实现分布式锁-可重入

redis实现的分布式锁是不可重入的，而redisson可以

![image-20230705170901080](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705170901080.png)

### redisson实现分布式锁-主从一致性

![image-20230705171126744](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705171126744.png)



## Redis集群方案

三种，主从复制、哨兵模式、分片集群。

主要优势：

1. 可以横向扩展缓解写压力和存储压力，支持动态扩容和缩容。
2. 具备主从复制、故障转移（内置了Sentinel机制，无需单独布置Sentinel集群）等开箱即用的功能。

###主从复制：

单节点Redis的并发能力有上限，要进一步提高Redis的并发能力，需要搭建主从集群，实现读写分离。

一般主节点（master）负责写操作，从节点（slave/replica）负责读操作。主节点在进行写操作时，同时要主要进行数据同步，把数据同步给从节点，实现主从分离。

主从同步原理：

​		两种情况

1、主从全量同步

![image-20230705172655593](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705172655593.png)

流程：

1. 从节点请求主节点同步数据（replication id、offset）
2. 主节点判断是否是第一次请求，是第一次就与从节点同步版本信息（replication id、offset）
3. 主节点执行bgsave，生成RDB文件后，发送给从节点去执行
4. 在RDB生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）
5. 把生成之后的日志文件发送给从节点进行同步。

2、主从增量同步

![image-20230705173048746](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705173048746.png)

流程：

1. 从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次请求就获取从节点的offse值
2. 主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。

### 哨兵模式（保证redis的高并发高可用）

Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复（监控、自动故障恢复、通知）。

哨兵机制三个特点：

![image-20230705174439263](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705174439263.png)

#### 服务状态监控

Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令

- 主观下线：如果某sentinel节点发现某实例未在规定时间内响应，则认为该实例主观下线。
- 客观下线：若超过指定数量（quorum）的sentinel都认为该实例下线，则该实例客观下线。（quorum数量最好超过sentinel的一半）

哨兵选主规则：

![image-20230705220135126](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230705220135126.png)

#### Redis集群脑裂，该怎么解决？

![image-20230707095451997](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707095451997.png)



### Redis是的单点还是集群？哪种集群？

主从（一主一从）+哨兵就可以了。单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。

### Redis网络模型

![image-20230707143531769](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707143531769.png)

Redis网络模型主要是I/O多路复用和事件派发机制，影响单线程的速度的是I/O，接受数据及缓冲区向外写数据时用到了多线程

![image-20230707144513997](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230707144513997.png)

### I/O多路复用

是指利用单个线程同时监听多个Socket，并且在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前I/O多路复用采用的是epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。

### 分片集群

主从和哨兵可以解决高可用、高并发的问题，可是依然有两个问题没解决：

1. 海量数据存储问题
2. 高并发写问题

分片集群可以解决上述问题

部署多台 Redis 主节点（master），这些节点之间平等，并没有主从之说，同时对外提供读/写服务。缓存的数据库相对均匀地分布在这些 Redis 实例上，客户端的请求通过路由规则转发到目标 master 上。



## Redis常用的数据结构

5种基本数据结构：String、List、Set、Hash、Zset；

3种特殊数据结构：HyperLogLogs（基数统计）、Bitmap（位存储）、Geospatial（地理位置）；

![image-20230822164607815](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230822164607815.png)





## 使用 Set 实现抽奖系统怎么做

`SADD key member1 member2 ...`：向指定集合添加一个或多个元素。

`SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。

`SRANDMEMBER key count` : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。



## 使用 HyperLogLog 统计页面 UV 怎么做？

使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：

- `PFADD key element1 element2 ...`：添加一个或多个元素到 HyperLogLog 中。
- `PFCOUNT key1 key2`：获取一个或者多个 HyperLogLog 的唯一计数。

1、将访问指定页面的每个用户 ID 添加到 `HyperLogLog` 中。

```bash
PFADD PAGE_1:UV USER1 USER2 ...... USERn
```

2、统计指定页面的 UV。

```bash
PFCOUNT PAGE_1:UV
```



## Redisson分布式锁

Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。

### Redisson可重入锁原理

![img](https://img-blog.csdnimg.cn/dbc9b56faab3475484f8612ca1f1decd.png)

### Redisson分布式锁原理

![img](https://img-blog.csdnimg.cn/d23d11443add43cd9779b38f850b2944.png)

- **可重入**：利用hash结构记录线程id和重入次数
- **可重试**：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制
- **超时续约**：利用watchDog，每隔一段时间（releaseTime / 3），重置超时时间
- **主从一致性**：采用Redis集群主从同步，可解决主从一致性问题

**1**、不可重入Redis分布式锁：

- 原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示
- 缺陷：不可重入、无法重试、锁超时失效

**2**、可重入的Redis分布式锁：

- 原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待
- 缺陷：redis宕机引起锁失效问题

**3**、Redisson的multiLock：

- 原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功
- 缺陷：运维成本高、实现复杂 

---

# Linux

---

# Spring



## Spring IOC和依赖注入

【@Bean @Autowired和@Resource注解的区别？】

IoC（控制反转）是一种设计思想：将原本在程序中手动创建对象的控制权，交给Spring框架来管理。

控制：创建对象的权力

反转：控制权交给外部环境

@Bean：修饰的方法表示初始化一个对象并交由Spring IOC去管理，@Bean只能和@Component @Repository @Controller @Service @Configration配合使用

@Autowired：可修饰变量和方法，用于完成自动装配（将需要的外部资源注入）

@Resource：同上

==@Autowired与@Bean 区别==：

@Bean告诉Spring “这是此类的一个实例，请保留该类，并在我询问时将其还给我”；

@Autowired说 “请给我一个该类的实例，例如，我@Bean之前用注释创建的一个实例”；

==@Autowired与@Resource区别==：

@Autowired会先按byType去找，如果没找到，则会按照byName去找；

@Resource会先按byName去找，如果没找到，则会按照byType去找。如果设置了name属性，则只会按byName去找，找不到报错。



## AOP的应用场景

![image-20230530092731421](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230530092731421.png)



## Spring 框架中使用的设计模式

**工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。

**代理设计模式** : Spring AOP 功能的实现。

**单例设计模式** : Spring 中的 Bean 默认都是单例的。

**模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

**包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

**观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。

**适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。





## Bean的生命周期

1、通过BeanDifinition获取Bean的定义信息，其中封装了Bean的所有信息，如类的全路径、是否延迟加载、是否是单例等；

2、第一步创建Bean，调用构造函数实例化bean；

3、第二步Bean的依赖注入。例如一些set方法，平常通过@Autowire完成

4、第三步实现Aware接口，重写Aware方法执行

5、第四步bean的后置处理器BeanPostProcess，这是前置处理器

6、第五步初始化方法，实现接口InitializingBean

7、执行bean的后置处理器BeanPostProcess

8、销毁bean



## Spring中的循环依赖

循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A。循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖。

一级缓存：单例池。缓存已经初始化后的Bean对象，经历了完整的生命周期。

二级缓存：缓存早期的Bean对象，还没有走完生命周期

三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象

# SpringMVC



## SpringMVC的执行流程

![image-20230725155622033](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230725155622033.png)

![image-20230726164439062](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230726164439062.png)





---

# SpringBoot



## SpringBoot自动配置原理

![image-20230725160029924](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230725160029924.png)



---

# MyBatis



## MyBatis#{}与${}的区别

`#{}`是 sql 的参数占位符（占位符），MyBatis 会将 sql 中的`#{}`替换为? 号，在 sql 执行前调用PreparedStatement的set方法来赋值；

`${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换；

`#{}` 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入。



## Mybatis的一、二级缓存

一级缓存：基于PerpetualCache的HashMap本地缓存（本质是一个HashMap），其存储作用域为Session，当Session flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。

二级缓存：同样基于PerpetualCache的HashMap存储，它的存储作用域为Mapper(namespace)，并可自定义存储源，如Ehcache。默认不打开二级缓存，开启二级缓存需要在全局配置文件和映射文件中开启配置才行

### Mybatis的二级缓存什么时候会清理缓存中的数据

当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了新增、修 改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear



## Mybatis执行流程

![image-20230726170538208](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230726170538208.png)

![image-20230726170547763](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230726170547763.png)



## 延迟加载及原理

延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时 就不加载数据。

延迟加载在底层主要使用的CGLIB动态代理完成的 

第一是，使用CGLIB（C G lib）创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的mapper  

第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null 值，再执行sql查询 

第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了

# 微服务

![image-20230726172007836](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230726172007836.png)



## Spring Cloud

### 服务注册

#### Spring Cloud五大组件

Eureka （U re 卡）: 注册中心 

Ribbon (re 本): 负载均衡

 Feign（奋） : 远程调用

Hystrix : 服务熔断

 Zuul/Gateway : 网关

![image-20230726172321583](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230726172321583.png)

#### 服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？

三大功能模块：服务注册、服务发现、服务状态监控

服务注册：服务提供则需要把自己的注册信息提交到注册中心Eureka进行保存，例如服务名称、IP、端口

服务发现：消费者回向Eureka进行服务列表拉取，如果服务提供者有集群，消费者会采用负载均衡算法，选取一个发起调用。

服务状态监控：服务提供者会每隔30秒钟向Eureka发送心跳，报告健康状态，超过90秒没有发送，从Eureka中剔除。

#### nacos与eureka的区别

作为注册中心，nacos还支持**配置中心**；nacos比eureka更加好用一些

相同点：

两者都支持服务注册和服务拉取，都支持服务提供者采用心跳方式做健康检测

区别点：

- nacos服务端主动检测服务者状态，临时实例采用心跳模式，非临时实例采用的是主动检测模式
- Ncaos支持列表服务变更的消息推送，服务列表更新及时
- 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
- Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式； Eureka采用AP方式

### 负载均衡

#### 负载均衡如何实现的

在服务调用过程中的负载均衡一般使用SpringCloud的Ribbon 组件实现 , Feign的底层已经自动集成了Ribbon , 使用起来非常简单 当发起远程调用时，ribbon先从注册中心拉取服务地址列表，然后按照一定 的路由策略选择一个发起远程调用，一般的调用策略是轮询

#### Ribbon的负载均衡策略有哪些

RoundRobinRule：简单轮询服务列表来选择服务器 

WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小 

RandomRule：随机选择一个可用的服务器 

ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。 而后再对Zone内的多个服务做轮询(默认)

#### 自定义负载均衡如何实现

提供了两种方式：

 1，创建类实现IRule接口，可以指定负载均衡策略，这个是全局的，对所有的远程调用都起作用 

2，在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略，只是对配置的这个服务生效远程调用

### 熔断、降级

服务雪崩是指一个服务失败，导致整条链路的服务都失败的情形，一般我们 在项目解决的话就是两种方案，第一个是服务降级，第二个是服务熔断，如 果流量太大的话，可以考虑限流

服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于 确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际 开发中与feign接口整合，编写降级逻辑

服务熔断：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超 过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务 不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常 请求

### 监控

#### 微服务监控工具

SpringBoot-admin

skywalking

zipkin（链路追踪工具）

promethus+Grafana（链路追踪工具）



## 业务相关

###  限流

#### 为什么要限流

1、并发的确比较大（突发流量）

2、防止用户恶意刷接口

#### 限流的实现方式

Tomcat：可以设置最大连接数

Nginx，漏油算法

网关，令桶油算法

自定义拦截器

1. 我们当时采用的nginx限流操作，nginx使用的漏桶算法来实现过滤，让请求 以固定的速率处理请求，可以应对突发流量，我们控制的速率是按照ip进行 限流，限制的流量是每秒20
2. 我们当时采用的是spring cloud gateway中支持局部过滤器 RequestRateLimiter来做限流，使用的是令牌桶算法，可以根据ip或路径进 行限流，可以设置每秒填充平均速率，和令牌桶总容量

漏桶算法是把请求存入到桶中，以固定速率从桶中流出，可以让我们的服务 做到绝对的平均，起到很好的限流效果 

令牌桶算法在桶中存储的是令牌，按照一定的速率生成令牌，每个请求都要 先申请令牌，申请到令牌以后才能正常请求，也可以起到很好的限流作用 

它们的区别是，漏桶和令牌桶都可以处理突发流量，其中漏桶可以做到绝对 的平滑，令牌桶有可能会产生突发大量请求的情况，一般nginx限流采用的 漏桶，spring cloud gateway中可以支持令牌桶算法

### 什么是CAP

CAP主要是在分布式项目下的一个理论。包含了三项，一致性、可用性、分区容错性 

一致性(Consistency)是指更新操作成功并返回客户端完成后，所有节点在同一时间 的数据完全一致(强一致性)，不能存在中间状态。

可用性(Availability) 是指系统提供的服务必须一直处于可用的状态，对于用户的每 一个操作请求总是能够在有限的时间内返回结果。 

分区容错性(Partition tolerance) 是指分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

![image-20230727172236661](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230727172236661.png)

### BASE理论

BASE是CAP理论中AP方案的延伸，核心思想是即使无法做到强一致性 （StrongConsistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。

它的思想包含三方面：

1、Basically Available（基本可用）：基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。 2、Soft state（软状态）：即是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 

3、Eventually consistent（最终一致性）：强调系统中所有的数据副本，在 经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

### 分布式事务解决方案

![image-20230727172910687](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230727172910687.png)

![image-20230727172953741](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230727172953741.png)

![image-20230727173055959](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230727173055959.png)

用的最多AT

![image-20230727173200070](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230727173200070.png)

![image-20230727173423968](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230727173423968.png)

### xxl-job

![image-20230727174238805](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230727174238805.png)



#### xxl-job路由策略有哪些？

xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、 分片广播…

#### xxl-job任务执行失败怎么解决

第一：路由策略选择故障转移，优先使用健康的实例来执行任务 

第二，如果还有失败的，我们在创建任务时，可以设置重试次数 

第三，如果还有失败的，就可以查看日志或者配置邮件告警来通知相关负责人解决



## 消息中间件

### RabbitMQ

#### 什么是AMQP

高级消息队列协议；面向消息中间件的协议；AMQP的特征是面向消息、队列、路由、可靠性、安全。

AMQP三大组件：

交换机(Exchange)：消息代理服务器中用于把消息路由到队列的组件。

队列（queue）：用来存储消息的数据结构，位于硬盘或内存中。

绑定（Binding）：一套规则，告知交换器消息应该将消息投递给哪个队列。

#### RabbitMQ如何保证消息不丢失

1. 开启生产者确认机制，确保生产者的消息能到达队列，如果报错可 以先记录到日志中，再去修复数据
2. 开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交 换机、队列、和消息都要做持久化
3. 开启消费者确认机制为auto，由spring确认消息处理成功后完成 ack，
4. 开启消费者失败重试机制，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次 还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理

#### RabbitMQ消息的重复消费问题（任何MQ解决方法相同）

开启了消费者自动确认机制，当服务还没有给MQ确认的时候，服务宕机了，导致服务恢复以后，又重写消费了一次。

业务是否具备唯一id标识，例如订单id标识，处理消息时，先去数据库查询是否有该数据，不存在代表没有处理过，可以正常执行；存在则不需要再消费了。

其他解决方案：

redis分布式锁、数据库的锁都是可以的（没有唯一标识id 性能好）

#### RabbitMQ中死信交换机 （RabbitMQ延迟队列）

延迟队列：进入队列的消息会被延迟消费的队列

场景：超时订单、限时优惠、定时发布



### Kafka



---

# 计算机网络



## Cookie 和 Session 区别

`Cookie` 数据保存在客户端(浏览器端)，`Session` 数据保存在服务器端。



### 如何使用 Session-Cookie 方案进行身份验证？

通过 `SessionID` 来实现特定的用户，`SessionID` 一般会选择存放在 Redis 中。举个例子：

1. 用户成功登陆系统，然后返回给客户端具有 `SessionID` 的 `Cookie` 。
2. 当用户向后端发起请求的时候会把 `SessionID` 带上，这样后端就知道你的身份状态了。

详细过程：

1. 用户向服务器发送用户名、密码、验证码用于登陆系统。
2. 服务器验证通过后，服务器为用户创建一个 `Session`，并将 `Session` 信息存储起来。
3. 服务器向用户返回一个 `SessionID`，写入用户的 `Cookie`。
4. 当用户保持登录状态时，`Cookie` 将与每个后续请求一起被发送出去。
5. 服务器可以将存储在 `Cookie` 上的 `SessionID` 与存储在内存中或者数据库中的 `Session` 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。



## TCP 与 UDP 的区别

### TCP:

面向连接，可靠传输（传递数据之前，会有三次握手建立连接，数据传递时，有确认、窗口、重传、拥塞控制机制），有状态，传输速率低，面向字节流，点对点通信（不支持广播或多播服务）

### UDP:

非面向连接，不保证数据不丢失、是否顺序传达，无状态服务，传输速率快，面向报文，支持广播或多播服务。

![image-20230606202309845](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230606202309845.png)



## OSI七层协议   /   TCP/IP四层协议

![image-20230802154932271](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230802154932271.png)



---

# 操作系统



## 多线程同步几种数据同步的方式

**互斥锁**（Mutex）、**条件变量**（condition variable）、**读写锁**（reader-writer lock）、**信号量**（semaphore）；



## 进程之间的通信方式

**管道/匿名管道(Pipes)**：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。

**有名管道(Named Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。有名管道遵循 **先进先出** 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）

**信号(Signal)**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

**消息队列(Message Queuing)**：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。**

**信号量(Semaphores)**：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

**共享内存(Shared memory)**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。

**套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

# 数据结构



## 红黑树

`红黑树的性质`: 红黑树是一棵**二叉搜索树**，在每个节点增加了一个存储位记录节点的颜色，可以是RED或BLACK；通过任

意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。

- 每个节点颜色不是黑色，就是红色
- 根节点是黑色的，叶节点是不存储数据的黑色空节点
- 如果一个节点是红色，那么它的两个子节点就是黑色的(没有连续的红节点)
- 对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点

一棵有n个节点的红黑树，高度最多为2log（n+1）

---

# 杂



## 在实际开发中为什么不能用浮点类型来存金钱的数据，浮点类不精确的本质是什么？

即便是Double也无法完整表示大数值的准确值，不能表示的部分被舍去，造成精度损失。使用BigDecima避免。



## Springboot跟tomcat是多线程还是多进程？

Spring Boot框架是一个可以实现多线程的框架，不是一个线程安全的框架；



## 剧本杀拼车系统

工作内容：

- **缓存业务构建**。静态页面和惰性数据全部存放至Redis中，热点数据通过监控阅读激增量并于每天4点由定时任务进行预热，并且对一些常规缓存问题进行处理。
- **主页推荐和拼车推荐**。主页推荐功能通过收集用户最近30天点击的剧本标签，将其存入Redis，下次进入主界面时通过Redis中标签随机加载。拼车功能将提取用户的个人简介和标签，通过模糊匹配预设关键词功能存入Redis，拼车时基于此数据进行推荐；
- **优惠卷秒杀和超卖问题。**实现秒杀下单并解决库存超卖问题。
- **签掉、点赞、附近的人**。签到功能通过redis的BitMap数据结构实现点赞功能。点赞直接存入redis，当点赞数量到达100时更新数据库。

工作内容：

- **短信登录功能。**基于Redis+Token实现登录功能。
- **缓存业务构建**。Caffeine和Redis实现多级缓存，热点数据由定时任务进行缓存预热，并对缓存生产问题进行兜底，解决缓存不一致问题。
- **主页和拼车推荐**。通过Redis中标签随机加载实现主页推荐，通过模糊匹配预设关键词实现拼车推荐。
- **秒杀和超卖问题。**实现优惠券秒杀下单并解决库存超卖问题，实现一人一单功能。
- **签掉、点赞、关注、附近的人**。通过Redis的BitMap、GEO数据结构实现，Feed流获取关注推送信息。

工作内容：

- **短信登录功能。**使用SpringSecurity设计权限认证服务，支持账号密码、验证码登录。
- **缓存业务构建**。Caffeine和Redis实现多级缓存，热点数据由定时任务进行缓存预热，并对缓存生产问题进行兜底，解决缓存不一致问题。
- **主页和拼车推荐**。通过Redis中标签随机加载实现主页推荐，通过模糊匹配预设关键词实现拼车推荐。
- **秒杀和超卖问题。**实现优惠券秒杀下单并解决库存超卖问题，实现一人一单功能。
- **签掉、点赞、关注、附近的人**。通过Redis的BitMap、GEO数据结构实现，Feed流获取关注推送信息。



## 新闻移动端web应用

工作内容：

- **分库分表**。运用MyCat数据库中间件计算，对系统数据进行分库分表，提升系统数据层性能；
- **消息通知**。运用Kafka完成内部系统消息通知，与客服端系统消息通知，以及实时数据计算；
- **敏感词过滤**。运用DFA算法实现敏感词过滤，并结合阿里云图片文本审核实现三轮高效审核；
- **文章查询**。运用Elatucsearch实现检索服务设计，对冷数据，文章数据建立索引，保证冷数据，文章查询性能。

工作内容：

- **延迟服务实现**。使用RabbitMQ实现延迟队列效果；
- **消息通知**。运用Kafka完成内部系统消息通知，与客服端系统消息通知，以及实时数据计算；
- **文章审核功能**。实现敏感词过滤，并结合阿里云图片文本审核实现三轮高效审核；
- **文章查询**。运用Elasticsearch实现检索服务设计，对冷数据，文章数据建立索引，保证冷数据，文章查询性能；
- **定时业务场景**。定时发布、定时下架、定时计算热点文章，使用XXL-JOB实现分布式定时任务调度。

---

# 算法



## 常用函数

集合转为整型数组

```java
set2.stream().mapToInt(x -> x).toArray();
```

`set2` 是一个 Set 集合，`stream()` 方法用于将集合转换为流，以便进行操作。

使用 `mapToInt(x -> x)` 对流中的元素进行映射和转换。这里的 `x -> x` 表示一个 Lambda 表达式，它将流中的每个元素 `x` 映射为相同的整型值 `x`。

使用 `toArray()` 将转换后的流元素收集到一个整型数组中。

### substring()

`substring()` 是String类的一个方法，可以用于从给定字符串中提取子字符串。它有两种不同的重载形式：

1. `substring(int beginIndex)`
   - 参数：`beginIndex` 表示要开始提取子字符串的索引位置（包含该索引位置的字符）。
   - 返回值：返回从 `beginIndex` 开始到字符串末尾的子字符串。
2. `substring(int beginIndex, int endIndex)`
   - 参数：`beginIndex` 表示要开始提取子字符串的索引位置（包含该索引位置的字符）；`endIndex` 表示要结束提取子字符串的索引位置（不包含该索引位置的字符）。
   - 返回值：返回从 `beginIndex` 开始到 `endIndex - 1` 的子字符串。

### charAt()

`charAt()` 是一个用于获取字符串中指定位置的字符的方法。它是 String 类的方法之一。

`charAt()` 方法接受一个整数参数 `index`，表示要获取字符的位置。索引从 0 开始，即第一个字符的索引为 0。

### toCharArray()

`toCharArray()` 是一个用于将字符串转换为字符数组的方法。它是 String 类的方法之一。

`toCharArray()` 方法没有参数，它会返回一个新的字符数组，该数组的元素是字符串中的字符，按照原始顺序排列。

### asList()

`Arrays.` 是一个用于将数组转换为列表的方法。它接受一个数组作为参数，并返回一个固定大小的列表，该列表是由数组元素构成的。

### getOrDefault（）

`map.getOrDefault(num, 0)`用于获取键`num`在`map`中对应的值。如果键`num`存在，则返回其对应的值；如果键`num`不存在，则返回默认值0。

### Arrays.sort()

char[]进行排序，使用可以使用`Arrays`工具类中的`sort()`方法。

```java
char[] array = {'d', 'b', 'a', 'c'};
System.out.println("Before sorting: " + Arrays.toString(array));
Arrays.sort(array);
System.out.println("After sorting: " + Arrays.toString(array));
输出：
Before sorting: [d, b, a, c]
After sorting: [a, b, c, d]
```

### valueOf()

`String.valueOf(chars)`是将字符数组(`char[]`)转换为字符串(`String`)的方法之一。

```java
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String key = String.valueOf(chars);
System.out.println(key);
输出：
Hello
```

`String.valueOf()`方法还可以用于将其他类型的数据转换为字符串，如整数、布尔值等。

### map.getOrDefault()

`map.getOrDefault(key, defaultValue)` 是 Java 中 Map 接口的一个方法，它的作用是获取指定键的对应值，如果该键不存在，则返回一个默认值。

具体参数和用法如下：

- `key`：要获取值的键。
- `defaultValue`：如果指定的键在 Map 中不存在，则返回的默认值。

`getOrDefault()` 方法的工作原理如下：

- 如果指定的键存在于 Map 中，则返回该键对应的值。
- 如果指定的键不存在于 Map 中，则返回默认值。

```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 5);
map.put("banana", 3);

int count = map.getOrDefault("orange", 0);
System.out.println(count); // 输出: 0

count = map.getOrDefault("apple", 0);
System.out.println(count); // 输出: 5
```



## 数组

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

### 二分查找：

左闭右闭--》left<=right

左闭右开--》left<right

二分法时间复杂度：O(logn)

### 移除元素：

双指针法：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

双指针时间复杂度：O(n)

### 滑动窗口：

滑动窗口其实也是双指针法的变种。

滑动窗口时间复杂度：O(n)

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

### 螺旋矩阵

通过限制每条边的循环条件来确定



## 哈希表

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**

数组做哈希表

### set做哈希表

什么时候用数组就不行了，需要用set。没有限制数值的大小，就无法使用数组来做哈希表了。

**主要因为如下两点：**

- 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
- 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

所以此时一样的做映射的话，就可以使用set了。

### map做哈希表

来说一说：使用数组和set来做哈希法的局限。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

map是一种`<key, value>`的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。



## 链表

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png)

### 链表的定义

```java
public class ListNode{
    int val;//节点上存储的元素
    ListNode next;//指向下一个节点的指针
    ListNode(){};//构造函数
    ListNode(int val){
        this.val = val;
    }
    ListNode(int val,ListNode next){
        this.val = val;
        this.next = next;
    }
}
```

### 删除链表的倒数第N个节点

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

### 链表相交

求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置

此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

否则循环退出返回空指针。

### 环形链表II

主要考察两知识点：

- 判断链表是否环
- 如果有环，如何找到这个环的入口

使用快慢指针

- 时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n
- 空间复杂度: O(1)



## 二叉树

### 构造二叉树

凡是构造二叉树，必须用前序遍历的方式



## 代码随想录

### 数组

|       题目       |                                                              |                           解题方法                           |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     二分查找     | 给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target` | 设置两指针，分别指向头尾，注意left和right比较关系，左闭右闭<=，左闭右开<；mid = （left + right）/ 2 |
|     移除元素     | 给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。 | 设置快慢指针，快指针移动中进行比较，当与目标数值不同时，满指针随快指针一同运动。 |
|  有序数组的平方  | 给你一个按 非递减顺序 排序的整数数组 `nums`，返回每个数字的平方组成的新数组，要求也按 非递减顺序排序。 | 采用双指针法，分别指向头尾，分别从左往右，从右往左进行平方比较，大的存入结果数组并移动指针，小的停留在原地。 |
| 长度最小的子数组 | 给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其和 `≥ target` 的长度最小的连续子数组 ，并返回其长度。 | 滑动窗口法，使用两个指针，定住一个指针，另一个指针依然可以移动 |
|    螺旋矩阵II    | 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。 | 确定好转多少圈，n/2表示转了几圈，奇数则将数值放入正方形正中间。注意控制左闭右开，四条边条件的判断 |

### 链表

|          题目           |                                                              |                           解题方法                           |
| :---------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      移除链表元素       | 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 新的头节点 。 | 设虚拟头节点，找到需要移除的元素，使得前一节点指向后一节点，删除当前节点。 |
|        反转链表         | 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。 | 先定义cur指针指向头节点，在定义一个pre指针为null。反转：把cur.next节点用tmp保存下来，再将cur.next指向pre；移动两指针：pre = cur， cur = tmp |
|  两两交换链表中的节点   | 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。 | 设立指针指向虚拟头节点，保存好temp指头节点，temp1指向头节点后两个位置的节点；进行两节点交换 |
| 删除链表的倒数第N个节点 |                   删除链表的倒数第N个节点                    | 设快慢指针，让fast先走n个单位，然后快慢指针同时移动，当快指针到底时，慢指针指向要删除节点的前一个节点，开始删除节点。 |
|        链表相交         | 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 | 先求出lenA、lenB的长度，使A为长的那条进行变化；求出长度差，然后移动curA，使得curA和curB处于同一起点。遍历curA和curB，遇到相同则直接返回。 |
|       环形链表 II       | 给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。* | 设立快慢指针，快指针以两步前进，慢指针一步前进。两指针会在环内相遇。然后设立两指针，一个从相遇节点一步出发，一个从头节点一步出发。 |

### 哈希表

|       题目       |                                                              |                           解题方法                           |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 有效的字母异位词 | 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。 | 设立一个26大小的数组，里面放入每个字母出现的次数，遍历S，每遇见字母，更新增加数组中对应下标的数值；遍历t，更新减少数组中的数值；查看数组中是否有小于0的数值存在。 |
|  两个数组的交集  | 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 唯一的。 | 设两个HashSet对象，set1添加nums1元素；判断nums2中元素是否在num1中；set2加入包含元素；再进行集合转数组输出 |
|      快乐数      |         编写一个算法来判断一个数 `n` 是不是快乐数。          | HashSet对象，n！=1并且set中不包含n时，set添加n数值，创造函数统计每个位数上数值平方求和后的sum，使得sum = n ，继续进行循环判断 |
|     两数之和     | 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值target的那 两个整数，并返回它们的数组下标。 | 创建一个大小为2的res数组存放结果；判断num数组是否为空或长度为0；创建Hashmap数组，分别放数值和下标；循环求解，temp为目标值与num[i]的差，判断差值是否再map集合中，若在，填入res，若不在，存放num[i]，i于map中； |
|   四数相加 II    | 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：  `0 <= i, j, k, l < n` ；`nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0` | 创建一个Hashmap集合存放temp值和value次数；遍历num1、num2，找到i+j=temp值，如果map中包含，则value值+1，不包含则存入map；遍历num3和num4，找到i+j值，如果map中包含0-temp，res则等于 |
|     三数之和     | 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 | 定义一个List<List<Integer>>二位整数列表，排序num数组；开始循环，使用if(i > 0 && nums[i] == nums[i - 1]){continue；}跳过重复元素；定义双指针left=i+1，right=length-1；... |
|     四数之和     | 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复） |                在三数之和的基础上再套一层循环                |

### 字符串

|                     题目                      |                                                              |                           解题方法                           |
| :-------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|                  反转字符串                   | 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 |                    使用双指针法解决问题。                    |
|                 反转字符串 II                 | 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 | 每次递增2k，表示每隔2k个字符进行处理。在循环体内，首先将起始位置start和结束位置end确定为当前处理的片段。 |
|              反转字符串中的单词               | 给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 |                                                              |
| 实现 strStr()，找出字符串中第一个匹配项的下标 | 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。 |             编写naxt数组方法；再根据next数组寻找             |
|                重复的子字符串                 | 给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。 |                           KMP算法                            |

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

### 栈与队列

|             题目             |                                                              |                           解题方法                           |
| :--------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|          有效的括号          | 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。 | 定义一个栈；遍历过程中每遇到一次左括号，则在栈中加入对应的右括号；当遇到右括号时，则与栈顶元素进行比较是否相同，相同则弹出，不相同则返回false（同时注意判断此时栈绝不为空）；遍历结束后，栈一定为空 |
| 删除字符串中的所有相邻重复项 | 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 | 定义一个栈；遍历过程中，如果栈为空或者元素不等于栈顶元素，则加入栈，否则弹出栈顶元素；建立空字符串；以弹出元素在左，字符串在右进行拼接 |
|       逆波兰表达式求值       | 给你一个字符串数组 `tokens` ，表示一个根据逆波兰表示法表示的算术表达式。 | 定义一个栈；遍历过程中，遇见数字则加入栈（需要将字符类型转换为整型加入）；遇见操作符，则弹出两个数字进行四则运算，并将运算后得到的一个数字加入栈中；最后输出栈中所剩最后一个元素 |
|        滑动窗口最大值        | 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。 | 定义一个数组存放输出结果；自定义队列，队列为单调队列（保证队列首项最大）；向队列中加入前K个元素；每次加入元素，判断是否需要输出队列中元素，然后在数组中添加队列队首元素 |
|       前 K 个高频元素        | 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 任意顺序返回答案。 | 定义一个map数组存放元素和出现次数；将数组中元素加入到map中；定义一个优先级队列； |

优先级队列底层实现就是堆

### 二叉树

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |



## Hot 100

### 两数之和

![image-20230714173520732](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230714173520732.png)

```伪代码
定义结果数组res[]大小为2；
判断nums为null或长度不是否为0；
定义一个HashMap集合map存放（数值，下标）；
循环（数组）
	定义 temp 为目标值和nums[i]的差；
	if判断temp是否在map之中；（使用map.containsKey(temp)）
		在，存入res[0],res[1]；
		不在，存入map；
返回res[]
```

### 字母异位词分组

![](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230714210122887.png)

```伪代码
判断strs是否为null或长度为0；
定义map哈希表，Map<String,List<String>>
循环（str：strs）
	将str转换为字符串char[];
	Arrays.sort（char）排序char数组；
	String.ValueOf（char）转化为字符串key；
	if判断key是否在map中；(使用map.containsKey（key))
		不在，存入map.put（key，new ArrayList（））；
	在，map.get（key）.add(str);
返回 new ArrayList<String>(map.values()); 
```

### 最长连续序列

![image-20230715094732528](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230715094732528.png)

```伪代码
定义一个Set类型实现类HashSet哈希表hash；
将nums元素加入到hash中（排除了重复项）；
定义int res；
for each循环（x：hash）
	if判断x-1是否存在
		存在，continue；
		不存在
			暂定当前元素为cur；
			while判断cur是否存在；
				cur++；（找到cur+1元素）；
				Math.max（res，cur-x）；为什么不是cur-x+1，因为从x开始；
返回res；
```

### 移动零

![image-20230715105318115](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230715105318115.png)

```伪代码
初始化lrft，right左右指针为0；
	循环（right<nums.length）
		if判断nums[right]不等于0
			与左指针数值进行交换；swap（）函数
			左指针向左移动；
		右指针向右移动；
自定义swap（）交换函数；
```

### 盛最多水的容器

![](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230715115900894.png)

 

```伪代码
定义左右指针，left=0，right=length-1；
定义res =0；
循环（left<right）
	面积area等于左右指针差*两指针中小的数值；
	比较res、area较大值；
	if判断（左右指针大小）
		左小，左指针右移；
		右小，右指针左移；
返回res；
```

### 接雨水

![image-20230715160431410](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230715160431410.png)

```伪代码
定义左右指针left=0，right=n-1；
定义左边最大值left_max，右边最大值right_max；
定义结果res；
循环（left<right）
	if判断左边高度是否小于右边高度
		小于，则
			判断当前高度是否大于left_max;
				大于，更新左最大值；
				小于，低洼形成，res加上（左最大值-当前高度）；
		 	左指针右移；
		大于，则
			判断当前高度是否大于right_max；
				大于，更新右最大值；
				小于，低洼形成，res加上（右最大值-当前高度）；
			右指针左移；
返回res；
```

### 无重复字符的最长子串

![image-20230715175004108](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230715175004108.png)

```伪代码
定义左右指针来设置滑动窗口；
定义max结果；
将字符串转化为char[];
定义HashSet<Character>；
for循环
	判断char[i]是否在set中
		在，char[left]移除；
		left右移；（该循环直到去除重复数）
	不在，将char[right]加入的set中；
	求出该循环中滑动窗口大小（temp）；
	与max比较大小；
返回max；
```

### 找到字符串中所有字母异位词

![image-20230715180644056](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230715180644056.png)

```伪代码
创建一个空列表 res 来存储结果，表示字母异位词的起始索引。
创建一个 HashMap 对象 map，用于存储目标字符串 p 中各个字符出现的次数。
初始化左指针 left 和右指针 right，分别指向字符串 s 的起始位置。
遍历目标字符串 p 中的每个字符，将其出现次数存储在 map 中。
创建另一个 HashMap 对象 window，用于存储滑动窗口中有效字符出现的次数。
初始化变量 len 为 0，表示窗口中含有目标字符串中字符的数量。
进入循环，当右指针 right 小于字符串 s 的长度时：
如果 map 中包含字符串 s 中的字符 s.charAt(right)：
将字符 s.charAt(right) 的出现次数加入 window 中。
如果 window 中字符 s.charAt(right) 的出现次数不超过 map 中的对应值，表示该字符是有效字符，增加 len 的值。
进入内循环，当 len 等于目标字符串 p 的长度时，表示窗口中包含了完整的目标子串：
如果窗口长度等于 p 的长度，则将左指针 left 添加到结果列表 res 中。
如果左指针 left 指向的字符在 map 中存在：
减少 window 中字符 s.charAt(left) 的出现次数。
如果 window 中字符 s.charAt(left) 的出现次数小于 map 中的对应值，说明目标子串中已经不包含该字符，减少 len 的值。
将左指针 left 右移一位。
右指针 right 右移一位。
返回结果列表 res。
该函数可以用于解决在字符串中寻找字母异位词的问题。

while(len == p.length()){
                if(right - left + 1 == p.length()){
                    res.add(left);
                }
                //如果左指针指的是有效字符,需要更改 window 中的 key 对应的 value
                //如果有效字符对应的数量比目标子串少，说明无法匹配了
                if(map.containsKey(s.charAt(left))){
                    window.put(s.charAt(left),window.get(s.charAt(left)) - 1);
                    if (window.get(s.charAt(left)) < map.get(s.charAt(left))) {
                        len--;
                    }
                }
                left++;
            }
这段代码是在内循环中，用于处理窗口包含完整目标子串的情况。让我来解释一下它的逻辑：

当窗口中的有效字符数量与目标字符串 p 的长度相等时，进入循环。
首先，检查窗口的长度是否等于目标字符串 p 的长度，如果是，则将左指针 left 的值添加到结果列表 res 中，表示找到了一个起始索引。
其次，检查左指针 left 所指向的字符是否是有效字符。如果是，说明该字符在目标字符串 p 中存在。
a. 更新窗口中有效字符的数量，减去左指针 left 所指向字符的出现次数。
b. 如果窗口中有效字符 s.charAt(left) 的出现次数小于目标字符串 p 中对应字符的出现次数，说明目标子串中已经不包含该字符，减少 len 的值。
将左指针 left 右移一位，继续下一轮循环。
```

### 和为 K 的子数组

![image-20230716155354731](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230716155354731.png)

```伪代码
定义前缀和preSum，定义结果res；
定义哈希表存储前缀和；
设置map（0，1），保证了初始前缀和为 0 的出现次数为 1；【注意map（0，1）】
for（循环数组）
	数组元素求和得preSum；
	判断map.containsKey(preSum - k);【注意preSum - k】
		包含，res+=value；
	不包含，将preSum存入map
返回res；
```

### 最小覆盖子串

![image-20230716163319324](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230716163319324.png)

```伪代码
定义need数组，存放t中出现次数；
for循环将t内元素存入；
定义窗口左右指针legt、right；
定义窗口大小size初始化 Integer.MAX_VALUE；
定义窗口起始位置startWindow；
定义所需元素总数count；
while循环（right<s.length（））
	if判断s.charAt（right）是在need中是否大于0；
		大于则count--；
	need（s.charAt（right））--；
	if判断count是否等于0
		判断need（s.charAt（left））是否小于零；
			小于则表示不需要了，将值++；
			left向右移动；
		判断窗口大小是否小于size
			小于，则更新size；
			并将startWindow更新；
		将need（s.charAt（left））++；
		left向右移动；
         所需总数count++；
	right右移；
返回子串，使用三目运算符；
```

### 最大子数组和

![image-20230717165042907](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230717165042907.png)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum > 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
```

### 合并区间

![image-20230717165144921](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230717165144921.png)

```伪代码

```

### 螺旋矩阵

![image-20230719145219516](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230719145219516.png)

​	

```伪代码
定义结果集res；
判断matrix是否为null或长度是否为0；
定义left、right、top、bottom；
定义numSum总数字和；
while循环判断当numSum>=1时
	顺时针旋转
	for循环（从左到右）
		加入res；numSum--；
	变更开头；（即top++）
	for循环（从上到下）
		加入res；numSum--；
	变更开头；（right--）
	for循环(从右到左)
		加入res；numSum--；
	变更开头；（bottom--）；
	for循环（从下到上）
		加入res；numSum--；
	变更开头；（left++）
返回res；
```

矩阵置零

![image-20230719161747901](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230719161747901.png)

```伪代码
将第一行第一列拿出来标记；
将存在零的标记

```

### 相交链表

![image-20230719163955549](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230719163955549.png)

```伪代码
定义A、B链表临时指针；
求链表A的长度
求链表B的长度
重置A、B链表临时指针在头节点处
让curA为最长链表的头，lenA为其长度（类swap）
求lenA、lenB长度差gap
让curA和curB在同一起点上（末尾位置对齐）
遍历curA 和 curB，遇到相同则直接返回

```

### LRU缓存

![image-20230720145436605](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230720145436605.png)

```伪代码
定义一个Node类
	构建节点类
定义一个双链表类
	定义head、tail；
	初始化双链表构造函数；
	定义双链表头节点插入方法；
	定义双链表删除指定节点方法；
	定义双链表删除尾节点，并返回尾节点的方法；
定义LRUCache类
	定义一个哈希表<Integer,Node>
	定义一个双链表cache；
	定义一个容量cap
	初始化LRUCache；
	get方法
		判断是否存在key
			不存在返回-1；
		存在，获得该key对应的节点暂存res；
		删除res，再头节点加入res（未来将节点提到最近使用位置）
	put方法
		定义节点n暂存key、value；
		判断是否存在key
			存在则移除该节点；
			存在，但cap满，则移除尾部节点；
		链表中加入节点n；
		map中加入该节点；
```

### 数组中的第K个最大元素

![image-20230720162943088](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230720162943088.png)

```伪代码
定义一个优先队列heap
for循环数组
	if判断（队列长队小于K）
		加入数值到队列中
	否则，如果，队列中最小数小于num
		删除小顶堆堆顶，num加入
返回队列中，小顶堆堆顶；
```



---

# 简历



## 登录

[SpringBoot+SpringSecurity+JWT实现认证和授权]()

Spring Security 的核心配置就是继承 WebSecurityConfigurerAdapter 并注解@EnableWebSecurity 的配置。这个配置指明了用户名密码的处理方式、请求路径、登录、登出控制等和安全相关的配置。

---

使用Spring Security做登录，一般要实现UserDetailsService接口，代码如下：

```java
public interface UserDetailsService {
	UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

其中需要重写loadUserByName（）方法；

loadUserByName（）只有一个方法参数，所以实现多种用户类型登录，需要使得loadUserByName（）携带多个参数

方法：

新建接口CustomUserDetailsServiceInter继承UserDetailsService，重写loadUserByName（）方法；

实现CustomUserDetailsServiceInter接口的方法；

将所用使用到UserDetailsService的全部替换成CustomUserDetailsService。例如WebServiceConfigurer、AutoServiceConfigurer；

将DaoAuthenticationProvider的代码放到自定义的CustomerDaoAuthenticationProvider中，修改retrieveUser（）方法；

到webServiceConfigurer上配置CustomerDaoAuthenticationProvider



## 多级缓存

什么是缓存--》为什么用缓存--》缓存分类--》详细介绍及具体实现

### 什么是缓存

面对传统关系库不能应对所有业务场景，例如电商系统的秒杀场景、App首页的访问流量高峰场景等，容易造成数据库的瘫痪，缓存技术很好的解决了该问题。

缓存就是热点数据从数据库加载到内存中，当用户再次访问热点数据从内存中加载，减少了数据库的访问量，解决了高并发场景下数据库宕机问题。

### 为什么用缓存

从两个方面考虑，一方是应用系统的高并发场景，另一方面是应用系统的高性能情况。

#### 高并发场景

操作缓存能够承载的并发访问量远远大于访问数据库的，例如Redis，它读速度是11w次/s，写速度8w次/s。所以将数据库中访问比较高的数据存储到缓存中，用户请求直接访问缓存，不访问数据库，提高应用程序的并发量。

#### 高性能情况

用户第一次访问数据时，缓存中没有数据，用从数据库获取数据，因为是从磁盘中拿数据，读取数据过程比较慢。拿到数据后将数据存储到缓存，第二次访问数据，直接访问缓存获取，缓存直接操作内存的，访问数据比较快。

### 缓存分类

本地缓存、分布式缓存、多级缓存（ 根据缓存和应用程序是否属于同一个进程，将缓存分为本地缓存和分布式缓存。）

#### 本地缓存

和应用程序在同一个进程内的内存空间去存储数据，数据的读写都是在同一个进程内完成的。

优点：

**读取速度快，但是不能进行大数据量存储。**本地缓存不需要远程网络请求去操作内存空间，没有额外的性能消耗，所以读取速度快。但是由于本地缓存占用了应用进程的内存空间，比如java进程的jvm内存空间，故不能进行大数据量存储。

缺点：

**应用程序集群部署时，会存在数据更新问题（数据更新不一致）**。本地缓存一般只能被同一个应用进程的程序访问，不能被其他应用程序进程访问。在单体应用集群部署时，如果数据库有数据需要更新，就要同步更新不同服务器节点上的本地缓存的数据来保证数据的一致性，但是这种操作的复杂度高，容易出错。可以基于redis的发布/订阅机制来实现各个部署节点的数据同步更新。

**数据会随着应用程序的重启而丢失**。因为本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。

实现：

- 缓存存储的数据一般都是key-value键值对的数据结构，在java语言中，常用的字典实现包括 HashMap 和 ConcurretHashMap。

- 除了上面说的实现方式以外，也可以用Guava、Ehcache以及Caffeine等封装好的工具包来实现本地缓存。

#### 分布式缓存

分布式缓存是独立部署的服务进程，并且和应用程序没有部署在同一台服务器上，所以是需要通过远程网络请求来完成分布式缓存的读写操作，并且分布式缓存主要应用在应用程序集群部署的环境下。

优点：

**支持大数据量存储**。分布式缓存是独立部署的进程，拥有自身独自的内存空间，不需要占用应用程序进程的内存空间，并且还支持横向扩展的集群方式部署，所以可以进行大数据量存储。

**数据不会随着应用程序重启而丢失**。分布式缓存和本地缓存不同，拥有自身独立的内存空间，不会受到应用程序进程重启的影响，在应用程序重启时，分布式缓存的存储数据仍然存在。

**数据集中存储，保证数据的一致性**。 当应用程序采用集群方式部署时，集群的每个部署节点都有一个统一的分布式缓存进行数据的读写操作，所以不会存在像本地缓存中数据更新问题，保证了不同服务器节点的数据一致性。

**数据读写分离，高性能，高可用**。分布式缓存一般支持数据副本机制，实现读写分离，可以解决高并发场景中的数据读写性能问题。而且在多个缓存节点冗余存储数据，提高了缓存数据的可用性，避免某个缓存节点宕机导致数据不可用问题。

缺点：

**数据跨网络传输，读写性能不如本地缓存**。分布式缓存是一个独立的服务进程，并且和应用程序进程不在同一台机器上，所以数据的读写要通过远程网络请求，这样相对于本地缓存的数据读写，性能要低一些。

实现：

MemCached 、 Redis。

#### 多级缓存

基于本地缓存和分布式缓存的优缺点，多级缓存应运而生，在实际的业务开发中一般也是采用多级缓存。**注意：本地缓存一般存储更新频率低，访问频率高数据，分布式缓存一般存储更新频率很高的数据。**

**多级缓存的请求流程：本地缓存作为一级缓存，分布式缓存作为二级缓存**。当用户获取数据时，先从一级缓存中获取数据，如果一级缓存有数据则返回数据，否则从二级缓存中获取数据。如果二级缓存中有数据则更新一级缓存，然后将数据返回客户端。如果二级缓存没有数据则去数据库查询数据，然后更新二级缓存，接着再更新一级缓存，最后将数据返回给客户端。

实现：

可以使用Guava或者Caffeine作为一级缓存，Redis作为二级缓存。

### 本地缓存详细介绍及具体实现

#### 本地缓存应该具有的功能

1. 超过最大限制有对应淘汰策略，如LRU、LFU
2. 过期时间淘汰，如定时、懒式、定期；
3. 持久化
4. 统计监控

#### 本地缓存方案选型

#####  使用ConcurrentHashMap实现本地缓存

缓存的本质就是存储在内存中的KV数据结构，对应的就是jdk中线程安全的ConcurrentHashMap，但是要实现缓存，还需要考虑淘汰、最大限制、缓存过期时间淘汰等等功能。

优点：实现简单，不需要引入第三方包，比较适合一些简单的业务场景。缺点是如果需要更多的特性，需要定制化开发，成本会比较高，并且稳定性和可靠性也难以保障。对于比较复杂的场景，建议使用比较稳定的开源工具。

##### 基于Guava Cache实现本地缓存

Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：

- 支持最大容量限制
- 支持两种过期删除策略（插入时间和访问时间）
- 支持简单的统计功能
- 基于LRU算法实现

##### 基于Caffeine实现本地缓存

 Caffeine是基于java8实现的新一代缓存工具，缓存性能接近理论最优，可以看作是**Guava Cache的增强版**，功能上两者类似，不同的是Caffeine采用了一种结合LRU、LFU优点的算法：W-TinyLFU，在性能上有明显的优越性。

##### 基于Encache实现本地缓存

Encache是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。同Caffeine和Guava Cache相比，Encache的功能更加丰富，扩展性更强。

优点：

- 支持多种缓存淘汰算法，包括LRU、LFU和FIFO
- 缓存支持堆内存储、堆外存储、磁盘存储（支持持久化）三种
- 支持多种集群方案，解决数据共享问题

##### 选型方案对比

- 从易用性角度，Guava Cache、Caffeine和Encache都有十分成熟的接入方案，使用简单。
- 从功能性角度，Guava Cache和Caffeine功能类似，都是只支持堆内缓存，Encache相比功能更为丰富。
- 从性能上进行比较，Caffeine最优、GuavaCache次之，Encache最差(下图是三者的性能对比结果）。

#### 本地缓存问题及解决

两级缓存与数据库的数据要保持一致，一旦数据发生了修改，在修改数据库的同时，本地缓存、远程缓存应该同步更新。

解决方案：

- **MQ**

一般现在部署都是集群部署，有多个不同节点的本地缓存，可以使用MQ的广播模式，当数据修改时向MQ发送消息，节点监听并消费消息，删除本地缓存，达到最终一致性。

- **Canal + MQ**

如果你不想在你的业务代码发送MQ消息，还可以适用近几年比较流行的方法：订阅数据库变更日志，再操作缓存。Canal 订阅Mysql的 Binlog日志，当发生变化时向MQ发送消息，进而也实现数据一致性。

### 分布式缓存详细介绍及具体实现

Redis 是分布式缓存的首选。

**1、容量和性能可扩展**

通过增加集群中的机器数量，可以扩展缓存的容量和并发读写能力。同时，缓存数据对于应用来讲都是共享的。

**2、高可用性**

由于数据被分布在多台机器上，即使其中一台机器故障，缓存服务也能继续提供服务。

但是分布式缓存的缺点同样不容忽视。

**1、网络延迟**

分布式缓存通常需要通过网络通信来进行数据读写，可能会出现网络延迟等问题，相对于本地缓存而言，响应时间更长。

**2、复杂性**

分布式缓存需要考虑序列化、数据分片、缓存大小等问题，相对于本地缓存而言更加复杂。



举一个真实的案例，这次案例让笔者对于分布式缓存的认知提上了另一个台阶。

2014年，同事开发了比分直播的系统，所有的请求都是从分布式缓存 Memcached 中获取后直接响应。常规情况下，从缓存中查询数据非常快，但在线用户稍微多一点，整个系统就会特别卡。

通过 jstat 命令发现 GC 频率极高，几次请求就将新生代占满了，而且 CPU 的消耗都在 GC 线程上。初步判断是缓存值过大导致的，果不其然，缓存大小在 300k 到 500k 左右。

解决过程还比较波折，分为两个步骤：

1. **修改新生代大小**，从原来的 2G 修改成 4G，并精简缓存数据大小 (从平均 300k 左右降为 80k 左右)；
2. 把**缓存拆成两个部分**，第一部分是**全量数据**，第二部分是**增量数据**（数据量很小）。页面第一次请求拉取全量数据，当比分有变化的时候，通过 websocket 推送增量数据。

经过这次优化，笔者理解到：缓存虽然可以提升整体速度，但是在高并发场景下，缓存对象大小依然是需要关注的点，稍不留神就会产生事故。另外我们也需要合理地控制读取策略，最大程度减少 GC 的频率 , 从而提升整体性能。

### 多级缓存详细介绍及具体实现

2018年，笔者服务的一家电商公司需要进行 app 首页接口的性能优化。笔者花了大概两天的时间完成了整个方案，采取的是两级缓存模式，同时利用了 Guava 的惰性加载机制，整体架构如下图所示：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3175b504e1a747778d03ceeb0ac2aa0b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

缓存读取流程如下：

1、业务网关刚启动时，本地缓存没有数据，读取 Redis 缓存，如果 Redis 缓存也没数据，则通过 RPC 调用导购服务读取数据，然后再将数据写入本地缓存和 Redis 中；若 Redis 缓存不为空，则将缓存数据写入本地缓存中。

2、由于步骤1已经对本地缓存预热，后续请求直接读取本地缓存，返回给用户端。

3、Guava 配置了 refresh 机制，每隔一段时间会调用自定义 LoadingCache 线程池（5个最大线程，5个核心线程）去导购服务同步数据到本地缓存和 Redis 中。

优化后，性能表现很好，平均耗时在 5ms 左右。最开始我以为出现问题的几率很小，可是有一天晚上，突然发现 app 端首页显示的数据时而相同，时而不同。

也就是说： 虽然 LoadingCache 线程一直在调用接口更新缓存信息，但是各个 服务器本地缓存中的数据并非完成一致。 说明了两个很重要的点：

1、惰性加载仍然可能造成多台机器的数据不一致

2、LoadingCache 线程池数量配置的不太合理, 导致了线程堆积

最终，我们的解决方案是：

1、惰性加载结合消息机制来更新缓存数据，也就是：当导购服务的配置发生变化时，通知业务网关重新拉取数据，更新缓存。

2、适当调大 LoadigCache 的线程池参数，并在线程池埋点，监控线程池的使用情况，当线程繁忙时能发出告警，然后动态修改线程池参数。



适合多级缓存的两种业务场景：

●缓存的数据不会频繁修改，比较稳定；
●数据访问量特别大比如秒杀场景。

![img](https://img-blog.csdnimg.cn/3be78f9682ff48d595f0b3196b88f158.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR2ltdG9t,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)



## 实现主页推荐、拼车推荐

在应用中创建标签系统，对主页推荐内容进行标记，为这些推荐内容设立多个标签，将这些标签与内容的唯一标识关联到Redis中；

创建一个服务或控制器类，负责从Redis中随机加载标签，并根据加载到的标签获取相应的推荐内容；

例如使用Redis的`SRANDMEMBER`（srandmember）命令随机获取指定数量的标签；

---

同理创建一个服务或控制器类，实现拼车推荐；

根据用户输入的关键词，使用Redis的有序集合（sorted set）来存储关键词和相关内容之间的关联度。将用户输入的关键词模糊匹配到有序集合的键中，并根据关联度获取拼车推荐结果



## Redis解决秒杀超卖问题

对于高并发场景下的导致的超卖问题，最常见的解决方法就是：上锁

乐观锁 :就是乐观（认为线程安全一定不会发生），只要在每次对数据修改之前，判断其他线程是否对数据进行的修改来保证线程安全。

1、使用乐观锁版本号法 

就是在查询库存的步骤上加上一个版本号，每次修改完数据后给版本号＋1并在后面加上where条件判断版本号是否和修改前的一致；

2、CAS法

这个就是不用版本号了，直接在修改数据库后加上where条件判断库存是否是修改前的库存



**我们扣减库存的时候加上一个where条件判断库存是否大于0**







方案一：

### 利用乐观锁淘汰用户，解决超卖问题

方案原理：
（1）当用户购买时，通过watch来监视库存，如果库存在watch监视后发生改变，就会捕获异常而放弃对库存进行减一操作。
（2）如果库存没有监视到变化并且数量大于一时，则库存减一，并且执行任务。

缺点：

Redis 在尝试完成一个事务的时候，可能会因为事务的失败而重复尝试重新执行
保证商品的库存量正确是一件很重要的事情，但是单纯的使用 WATCH 这样的机制对服务器压力过大



要解决这个问题话，还是需要用到前面提到的乐观锁，用乐观锁去监视库存值，哪怕出现上述的情况，由于第一个线程修改库存值之后，版本号也被修改了。故第二个线程不能修改成功。所以就不会出现超卖的情况。

### 方案二：使用reids的 watch + multi + setnx 指令实现

（1）创建一个redis锁

在 Redis 中，可以通过使用 SETNX 命令来构建锁：rs.setnx(lock_name, uuid值)
而锁要做的事情就是将一个随机生成的 128 位 UUID 设置位键的值，防止该锁被其他进程获取。

（2）释放锁

锁的删除操作很简单，只需要将对应锁的 key 值获取到的 uuid 结果进行判断验证
符合条件（判断uuid值）通过 delete 在 redis 中删除即可，rs.delete(lockname)
此外当其他用户持有同名锁时，由于 uuid 的不同，经过验证后不会错误释放掉别人的锁.

（3）解决锁无法释放问题

在之前的锁中，还出现这样的问题，比如某个进程持有锁之后突然程序崩溃，那么会导致锁无法释放
而其他进程无法持有锁继续工作，为了解决这样的问题，可以在获取锁的时候加上锁的超时功能。

---

***解决方案1：***

引入队列，然后将所有写DB操作在单队列中排队，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。

优点：解决超卖问题，略微提升性能。

缺点：性能受限于队列处理机处理性能和DB的写入性能中最短的那个，另外多商品同时抢购的时候需要准备多条队列。

***解决方案2：***

将提交操作变成两段式，先申请后确认。然后利用Redis的原子自增操作（相比较MySQL的自增来说没有空洞），同时利用Redis的事务特性来发号，保证拿到小于等于库存阀值的号的人都可以成功提交订单。然后数据异步更新到DB中。

优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。

缺点：由于异步写入DB，可能存在数据不一致。另可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单数并没有达到库存阀值。



## BitMap签到

Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作；

可把Bitmaps想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在bitmaps中叫做偏移量；

单个bitmaps的最大长度是512MB，即2^32个比特位。bitmaps的最大优势是节省存储空间。比如在一个以自增id代表不同用户的系统中，我们只需要512MB空间就可以记录40亿用户的某个单一信息，相比mysql节省了大量的空间

---

按月来统计用户签到信息，签到记录为 1，未签到则记录为 0；

每一个 bit 位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这样一个月也只消耗31位（4字节）这种思路就称为位图（BitMap）

### Redis 中 是利用 string 类型数据结构实现 BitMap，为什么最大上限是 512M

Redis 中 是利用 string 类型数据结构实现 BitMap，因此最大上限是 512M，转换为 bit 则是 2^32个 bit 位。

在Redis 3.2及之前的版本中，一个字符串的最大长度被限制为512MB。这意味着，一个bitmap的长度也受到这个限制。

这个限制是出于性能和内存管理的考虑。较大的字符串可能会占用过多的内存，并且会对内存分配和回收造成一定的开销。为了避免这些问题，在设计Redis时设置了这个最大长度限制。

需要注意的是，从Redis 3.2.0版本开始，针对bitmap数据结构的操作进行了优化，允许使用BITFIELD命令对更长的bitmap进行操作，并且可以使用BITCOUNT命令计算更长的bitmap的位数。

如果你需要处理更大范围的bitmap数据，可以考虑将bitmap拆分为多个小的bitmap进行存储，并使用多个key来表示不同部分的位。这样可以绕过单个字符串长度的限制。但是需要注意在处理分片bitmap时需要进行额外的计算和管理。



## 点赞Zset

这里使用的策略是用redis的sortSet来代替set，因为set集合是无序的，但排行榜需要显示前5个点赞的用户，要想有序且不重复，只能用sortSet了，把之前的点赞功能，用户id存入set集合改为存入ZSet，使用sorce（key，value）方法来获取该键值的sorce，若没有则返回null，用来代替之前set的ismembet方法


使用到redis的set集合，key为blog的id，value为user的id，用set的ismembet方法判断，当前集合是否有userId，来判读该博客，用户是否已经点赞过了。每个key代表每条博客，每个key下的value集合代表所有点赞的用户id集合。



## GEO附近的人

Redis 在 3.2 版本中加入了对 GEO 的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据





## 延迟队列





## 消息通知





## 敏感词过滤





## 检索服务设计





## 分布式定时任务调度



# 黑马点评问题

![](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230807203951832.png)

## 项目有什么功能模块

认证登录、商家查询缓存、达人探店、好友关注、优惠券秒杀、附近商户、用户签到

### 认证登录

使⽤SpringSecurity设计权限认证服务，⽀持账号密码、验证码登录功能

### 商家查询缓存

### 达人探店

### 好友关注

关注推送采用Feed流

#### Feed流

Feed流两种常见产品：

Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈

智能排序 ：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户

本文是基于关注的好友来做Feed流，因此采用**Timeline**的模式。

该模式实现方案有三种：

1. **推模式**（也叫写扩散）：和名字一样，就是一种推的方式，发送者发送了一个消息后，立即将这个消息推送给接收者，但是接收者此时不一定在线，那么就需要有一个地方存储这个数据，这个存储的地方我们称为：同步库。推模式也叫写扩散的原因是，一个消息需要发送个多个粉丝，那么这条消息就会复制多份，写放大，所以也叫写扩散。这种模式下，对同步库的要求就是写入能力极强和稳定。读取的时候因为消息已经发到接收者的收件箱了，只需要读一次自己的收件箱即可，读请求的量极小，所以对读的QPS需求不大。归纳下，推模式中对同步库的要求只有一个：写入能力强。
2. **拉模式**（也叫读扩散）：这种是一种拉的方式，发送者发送了一条消息后，这条消息不会立即推送给粉丝，而是写入自己的发件箱，当粉丝上线后再去自己关注者的发件箱里面去读取，一条消息的写入只有一次，但是读取最多会和粉丝数一样，读会放大，所以也叫读扩散。拉模式的读写比例刚好和写扩散相反，那么对系统的要求是：读取能力强。另外这里还有一个误区，很多人在最开始设计feed流系统时，首先想到的是拉模式，因为这种和用户的使用体感是一样的，但是在系统设计上这种方式有不少痛点，最大的是每个粉丝需要记录自己上次读到了关注者的哪条消息，如果有1000个关注者，那么这个人需要记录1000个位置信息，这个量和关注量成正比的，远比用户数要大的多，这里要特别注意，虽然在产品前期数据量少的时候这种方式可以应付，但是量大了后就会事倍功半，得不偿失，切记切记。
3. **推拉结合模式**：推模式在单向关系中，因为存在大V，那么一条消息可能会扩散几百万次，但是这些用户中可能有一半多是僵尸，永远不会上线，那么就存在资源浪费。而拉模式下，在系统架构上会很复杂，同时需要记录的位置信息是天量，不好解决，尤其是用户量多了后会成为第一个故障点。基于此，所以有了推拉结合模式，大部分用户的消息都是写扩散，只有大V是读扩散，这样既控制了资源浪费，又减少了系统设计复杂度。但是整体设计复杂度还是要比推模式复杂。

- 如果产品中是双向关系，那么就采用推模式。
- 如果产品中是单向关系，且用户数少于1000万，那么也采用推模式，足够了。
- 如果产品是单向关系，单用户数大于1000万，那么采用推拉结合模式，这时候可以从推模式演进过来，不需要额外重新推翻重做。
- 永远不要只用拉模式。
- 如果是一个初创企业，先用推模式，快速把系统设计出来，然后让产品去验证、迭代，等客户数大幅上涨到1000万后，再考虑升级为推拉集合模式。

**本项目采用推模式：用SortedSet保存博客id，以及时间戳推送给粉丝收件箱**

### 优惠券秒杀

加锁解决超卖问题，Redisson分布式锁一人一单，Stream消息队列实现异步秒杀

**超卖**这种线程安全问题解决方案：

悲观锁：添加同步锁，让线程串行执行，认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行

- 优点：简单粗暴
- 缺点：性能一般
- 实现：Synchronized、Lock

乐观锁： 不加锁，在更新时判断是否有其它线程在修改。 认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。

- 优点：性能好
- 缺点：存在成功率低的问题
- 实现：版本号法、CAS法

#### 利用Redisson解决创建订单时一人一单问题

通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。可采用分布锁。

分布式锁：

![img](https://img-blog.csdnimg.cn/41e60dc2eabe4693ae0c362d67d88214.png)

基于Redis的分布式锁实现思路：

- 利用setnx ex获取锁，并设置过期时间，保存线程标示
- 释放锁时先判断线程标示是否与自己一致，一致则删除锁

**实现Redisson的分布式锁**：

Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。

**Redisson详情看上述笔记**

#### 基于Redis的Stream结构作为消息队列，实现异步秒杀下单 

异步秒杀下单流程图

![img](https://img-blog.csdnimg.cn/53f6bbbf1d11454e911a7be19e225a21.png)

**消息队列**（Message Queue），字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：

- 消息队列：存储和管理消息，也被称为消息代理（Message Broker）
- 生产者：发送消息到消息队列
- 消费者：从消息队列获取消息并处理消息

 Redis提供了三种不同的方式来实现消息队列：

- list结构：基于List结构模拟消息队列
- PubSub：基本的点对点消息模型
- Stream：比较完善的消息队列模型

![image-20230807213450776](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230807213450776.png)

**基于Stream的消息队列**

消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：

- ​    **消息分流：**队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度
- ​    **消息标示：**消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费
- ​    **消息确认：**消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。

### 附近商户

### 用户签到





## 项目的不足和改进



## session共享怎么实现的



## Redis怎么保证数据的一致性



## 讲讲分布式锁，还知道其他的吗



## 点赞如何实现的



## 优惠卷库存扣减流程



## 为什么用到lua脚本





# 知识点	

- [ ] 数据库事务
- [ ] 数据库索引
- [ ] JVM内存分区
- [x] synchronized锁升级

- [x] Java内存模型（JMM）
- [ ]  Synchronized、ReentrantLock实现原理
- [x] JVM内存模型
- [x] 类加载过程
- [ ] GC常用算法、垃圾回收器
- [ ] MySQL索引
- [ ] 事务隔离级别
- [ ] 数据库设计三⼤范式
- [ ] 缓存穿透、击穿、雪崩
- [ ] Redis集群
- [ ] Redis持久化
- [ ] IOC、AOP
- [ ] SpringCloud Alibba相关组件
- [ ] ES海量数据管理
- [ ] ES搜索业务

